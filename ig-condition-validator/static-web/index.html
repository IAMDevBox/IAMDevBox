<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IG Condition Validator</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            min-height: 100vh;
            padding: 2rem;
        }
        .container { width: 100%; }
        h1 { text-align: center; margin-bottom: 0.5rem; color: #f8fafc; }
        .subtitle { text-align: center; color: #94a3b8; margin-bottom: 2rem; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
        @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
        .card {
            background: #1e293b;
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid #334155;
        }
        .card-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 1rem; color: #f1f5f9; }
        .tabs { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
        .tab {
            padding: 0.5rem 1rem;
            border: none;
            background: #334155;
            color: #94a3b8;
            border-radius: 6px;
            cursor: pointer;
        }
        .tab:hover { background: #475569; }
        .tab.active { background: #3b82f6; color: white; }
        .form-group { margin-bottom: 1rem; }
        label { display: block; font-size: 0.875rem; color: #94a3b8; margin-bottom: 0.5rem; }
        input, textarea, select {
            width: 100%;
            padding: 0.75rem;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 8px;
            color: #e2e8f0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9rem;
        }
        input:focus, textarea:focus { outline: none; border-color: #3b82f6; }
        textarea { resize: vertical; min-height: 100px; }
        .condition-input { min-height: 120px; font-size: 1rem; }
        .inline-group { display: grid; grid-template-columns: 120px 1fr; gap: 0.75rem; }
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
        }
        .btn-primary { background: #3b82f6; color: white; }
        .btn-primary:hover { background: #2563eb; }
        .result-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        .result-passed { background: #064e3b; border: 1px solid #10b981; }
        .result-failed { background: #450a0a; border: 1px solid #ef4444; }
        .result-error { background: #451a03; border: 1px solid #f59e0b; }
        .result-icon { font-size: 1.5rem; }
        .condition-list { display: flex; flex-direction: column; gap: 0.75rem; }
        .condition-item {
            padding: 1rem;
            background: #0f172a;
            border-radius: 8px;
            border-left: 4px solid #334155;
        }
        .condition-item.passed { border-left-color: #10b981; }
        .condition-item.failed { border-left-color: #ef4444; }
        .condition-expr { font-family: 'Monaco', 'Menlo', monospace; font-size: 0.9rem; color: #f8fafc; margin-bottom: 0.5rem; }
        .condition-details { font-size: 0.85rem; color: #94a3b8; font-family: 'Monaco', 'Menlo', monospace; }
        .condition-details .fn-name { color: #dcdcaa; font-weight: 600; }
        .condition-details .fn-arg { color: #ce9178; }
        .condition-details .fn-result { color: #4ec9b0; }
        .condition-details .val-true { color: #4ec9b0; }
        .condition-details .val-false { color: #f14c4c; }
        .condition-details .op { color: #c586c0; font-weight: 600; }
        .condition-details .match-highlight { background: #365314; color: #a3e635; padding: 0 2px; border-radius: 2px; }
        /* Pattern highlighting for condition display */
        .fn-name { color: #dcdcaa; font-weight: 600; }
        .pattern-highlight { color: #ce9178; background: rgba(206, 145, 120, 0.15); padding: 0 3px; border-radius: 3px; }
        .val-true { color: #4ec9b0; font-weight: 600; }
        .val-false { color: #f14c4c; font-weight: 600; }
        .condition-suggestion { font-size: 0.85rem; color: #fbbf24; margin-top: 0.5rem; }
        .collapsible { cursor: pointer; user-select: none; }
        .collapsible:hover { opacity: 0.8; }
        .collapsible::before { content: '▶'; display: inline-block; margin-right: 0.5rem; font-size: 0.7rem; transition: transform 0.2s; color: #64748b; }
        .collapsible.expanded::before { transform: rotate(90deg); }
        .collapse-content { display: none; margin-top: 0.5rem; }
        .collapse-content.show { display: block; }
        .status-icon { margin-right: 0.5rem; }
        .hidden { display: none; }
        .headers-list { display: flex; flex-direction: column; gap: 0.5rem; }
        .header-row { display: grid; grid-template-columns: 1fr 1fr auto; gap: 0.5rem; }
        .btn-icon {
            padding: 0.5rem 0.75rem;
            background: #334155;
            border: none;
            border-radius: 6px;
            color: #94a3b8;
            cursor: pointer;
        }
        .btn-icon:hover { background: #475569; color: #e2e8f0; }
        .add-btn {
            margin-top: 0.5rem;
            background: transparent;
            border: 1px dashed #475569;
            color: #94a3b8;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
        }
        .add-btn:hover { border-color: #3b82f6; color: #3b82f6; }

        /* Syntax highlighting editor */
        .editor-container {
            position: relative;
            height: 150px;
        }
        .editor-backdrop {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            padding: 0.75rem;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 1rem;
            line-height: 1.5;
            white-space: pre;
            overflow: auto;
            pointer-events: none;
        }
        .editor-textarea {
            position: relative;
            width: 100%;
            height: 150px;
            padding: 0.75rem;
            background: transparent;
            border: none;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 1rem;
            line-height: 1.5;
            color: transparent;
            caret-color: #e2e8f0;
            resize: vertical;
            z-index: 1;
            overflow: auto;
            white-space: pre;
        }
        .editor-textarea:focus { outline: none; }
        .editor-textarea:focus ~ .editor-backdrop { border-color: #3b82f6; }
        .editor-textarea::placeholder { color: #64748b; }

        /* Token colors */
        .tok-keyword { color: #c084fc; font-weight: 500; }
        .tok-string { color: #86efac; }
        .tok-number { color: #fcd34d; }
        .tok-operator { color: #60a5fa; }
        .tok-function { color: #38bdf8; }
        .tok-property { color: #f8fafc; }
        .tok-bracket { color: #f472b6; }
        .tok-delimiter { color: #94a3b8; }

        /* Format button */
        .editor-toolbar {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .btn-small {
            padding: 0.25rem 0.75rem;
            font-size: 0.8rem;
            background: #334155;
            border: none;
            border-radius: 4px;
            color: #94a3b8;
            cursor: pointer;
        }
        .btn-small:hover { background: #475569; color: #e2e8f0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>IG Condition Validator</h1>
        <p class="subtitle">Debug ForgeRock Identity Gateway condition expressions (Static Version)</p>

        <div class="grid">
            <div>
                <div class="card">
                    <h3 class="card-title">Request</h3>
                    <div class="tabs">
                        <button class="tab" data-tab="manual">Manual</button>
                        <button class="tab active" data-tab="curl">cURL</button>
                    </div>

                    <div id="tab-manual" class="tab-content hidden">
                        <div class="form-group inline-group">
                            <div>
                                <label>Method</label>
                                <select id="method">
                                    <option value="GET">GET</option>
                                    <option value="POST">POST</option>
                                    <option value="PUT">PUT</option>
                                    <option value="DELETE">DELETE</option>
                                </select>
                            </div>
                            <div>
                                <label>Path</label>
                                <input type="text" id="path" value="/" placeholder="/api/users">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Query String</label>
                            <input type="text" id="query" placeholder="param1=value1&param2=value2">
                        </div>
                        <div class="form-group">
                            <label>Host</label>
                            <input type="text" id="host" placeholder="api.example.com">
                        </div>
                        <div class="form-group">
                            <label>Headers</label>
                            <div id="headers-list" class="headers-list">
                                <div class="header-row">
                                    <input type="text" placeholder="Header name" class="header-name">
                                    <input type="text" placeholder="Header value" class="header-value">
                                    <button class="btn-icon remove-header">×</button>
                                </div>
                            </div>
                            <button class="add-btn" id="add-header">+ Add Header</button>
                        </div>
                        <div class="form-group">
                            <label>Body</label>
                            <textarea id="body" placeholder='{"key": "value"}'></textarea>
                        </div>
                    </div>

                    <div id="tab-curl" class="tab-content">
                        <div class="form-group">
                            <label>Paste cURL command or URL</label>
                            <textarea id="curl-input" placeholder='curl -X GET "https://api.example.com/users?status=active" -H "Authorization: Bearer token"

Or just paste a URL:
https://api.example.com/path%2Fencoded?query=value%26other'></textarea>
                        </div>
                        <button class="btn btn-primary" id="parse-curl">Parse cURL / URL</button>
                    </div>
                </div>

                <div class="card" style="margin-top: 1.5rem;">
                    <h3 class="card-title">Condition Expression</h3>
                    <div class="form-group">
                        <div class="editor-toolbar">
                            <button class="btn-small" id="format-btn" title="Format expression">Format</button>
                        </div>
                        <div class="editor-container">
                            <textarea id="condition" class="editor-textarea" placeholder='${request.method == "GET" and contains(request.uri.path, "/api/")}'></textarea>
                            <div id="condition-highlight" class="editor-backdrop"></div>
                        </div>
                    </div>
                    <button class="btn btn-primary" id="diagnose-btn">Diagnose</button>
                </div>
            </div>

            <div>
                <div class="card">
                    <h3 class="card-title">Diagnosis Result</h3>
                    <div id="result-container">
                        <p style="color: #64748b; text-align: center; padding: 2rem;">
                            Enter a condition and click "Diagnose" to see results
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
// ============== Lexer ==============
const TokenType = {
    STRING: 'STRING', NUMBER: 'NUMBER', BOOLEAN: 'BOOLEAN', NULL: 'NULL',
    IDENTIFIER: 'IDENTIFIER', EQ: 'EQ', NE: 'NE', LT: 'LT', LE: 'LE', GT: 'GT', GE: 'GE',
    AND: 'AND', OR: 'OR', NOT: 'NOT', PLUS: 'PLUS', MINUS: 'MINUS',
    MULTIPLY: 'MULTIPLY', DIVIDE: 'DIVIDE', MODULO: 'MODULO', EMPTY: 'EMPTY',
    TERNARY_IF: 'TERNARY_IF', TERNARY_ELSE: 'TERNARY_ELSE',
    DOT: 'DOT', COMMA: 'COMMA', LPAREN: 'LPAREN', RPAREN: 'RPAREN',
    LBRACKET: 'LBRACKET', RBRACKET: 'RBRACKET',
    EXPR_START: 'EXPR_START', EXPR_END: 'EXPR_END', EOF: 'EOF', ERROR: 'ERROR'
};

const KEYWORDS = {
    'true': TokenType.BOOLEAN, 'false': TokenType.BOOLEAN, 'null': TokenType.NULL,
    'and': TokenType.AND, 'or': TokenType.OR, 'not': TokenType.NOT,
    'div': TokenType.DIVIDE, 'mod': TokenType.MODULO, 'empty': TokenType.EMPTY,
    'eq': TokenType.EQ, 'ne': TokenType.NE, 'lt': TokenType.LT,
    'le': TokenType.LE, 'gt': TokenType.GT, 'ge': TokenType.GE,
};

class Lexer {
    constructor(source) {
        this.source = source;
        this.pos = 0;
        this.line = 1;
        this.column = 1;
    }

    get current() { return this.pos < this.source.length ? this.source[this.pos] : null; }
    peek(offset = 1) { return this.pos + offset < this.source.length ? this.source[this.pos + offset] : null; }

    advance() {
        const char = this.current;
        this.pos++;
        if (char === '\n') { this.line++; this.column = 1; } else { this.column++; }
        return char;
    }

    skipWhitespace() { while (this.current && /\s/.test(this.current)) this.advance(); }

    readString(quote) {
        const line = this.line, column = this.column;
        this.advance();
        let result = '';
        while (this.current && this.current !== quote) {
            // Handle escape sequences
            if (this.current === '\\') {
                this.advance();
                const c = this.current;
                if (c === 'n') result += '\n';
                else if (c === 't') result += '\t';
                else if (c === '\\') result += '\\';
                else if (c === quote) result += quote;
                else result += c || '';
                this.advance();
            }
            // Handle URL-encoded quotes: %27 (') and %22 (")
            // These should be kept as-is in the string, not treated as string terminators
            else if (this.current === '%') {
                const next2 = (this.peek(1) || '') + (this.peek(2) || '');
                if (next2.toLowerCase() === '27' || next2.toLowerCase() === '22') {
                    // Include %27 or %22 as literal characters in the string
                    result += this.current; // %
                    this.advance();
                    result += this.current; // 2
                    this.advance();
                    result += this.current; // 7 or 2
                    this.advance();
                } else {
                    result += this.current;
                    this.advance();
                }
            }
            else {
                result += this.current;
                this.advance();
            }
        }
        if (this.current !== quote) throw new Error(`Unterminated string at ${line}:${column}`);
        this.advance();
        return { type: TokenType.STRING, value: result, line, column };
    }

    readNumber() {
        const line = this.line, column = this.column;
        let result = '';
        while (this.current && /\d/.test(this.current)) { result += this.current; this.advance(); }
        if (this.current === '.' && this.peek() && /\d/.test(this.peek())) {
            result += this.current; this.advance();
            while (this.current && /\d/.test(this.current)) { result += this.current; this.advance(); }
        }
        return { type: TokenType.NUMBER, value: result, line, column };
    }

    readIdentifier() {
        const line = this.line, column = this.column;
        let result = '';
        while (this.current && /[\w]/.test(this.current)) { result += this.current; this.advance(); }
        const lower = result.toLowerCase();
        const type = KEYWORDS[lower] || TokenType.IDENTIFIER;
        return { type, value: type === TokenType.IDENTIFIER ? result : lower, line, column };
    }

    tokenize() {
        const tokens = [];
        while (this.current) {
            const line = this.line, column = this.column;
            if (/\s/.test(this.current)) { this.skipWhitespace(); continue; }
            if ((this.current === '$' || this.current === '#') && this.peek() === '{') {
                const start = this.current; this.advance(); this.advance();
                tokens.push({ type: TokenType.EXPR_START, value: start + '{', line, column });
                continue;
            }
            if (this.current === '}') { this.advance(); tokens.push({ type: TokenType.EXPR_END, value: '}', line, column }); continue; }
            if (this.current === '"' || this.current === "'") { tokens.push(this.readString(this.current)); continue; }
            if (/\d/.test(this.current)) { tokens.push(this.readNumber()); continue; }
            if (/[a-zA-Z_]/.test(this.current)) { tokens.push(this.readIdentifier()); continue; }

            const two = this.current + (this.peek() || '');
            if (two === '==') { this.advance(); this.advance(); tokens.push({ type: TokenType.EQ, value: '==', line, column }); continue; }
            if (two === '!=') { this.advance(); this.advance(); tokens.push({ type: TokenType.NE, value: '!=', line, column }); continue; }
            if (two === '<=') { this.advance(); this.advance(); tokens.push({ type: TokenType.LE, value: '<=', line, column }); continue; }
            if (two === '>=') { this.advance(); this.advance(); tokens.push({ type: TokenType.GE, value: '>=', line, column }); continue; }
            if (two === '&&') { this.advance(); this.advance(); tokens.push({ type: TokenType.AND, value: '&&', line, column }); continue; }
            if (two === '||') { this.advance(); this.advance(); tokens.push({ type: TokenType.OR, value: '||', line, column }); continue; }

            const ops = { '<': TokenType.LT, '>': TokenType.GT, '+': TokenType.PLUS, '-': TokenType.MINUS,
                '*': TokenType.MULTIPLY, '/': TokenType.DIVIDE, '%': TokenType.MODULO, '!': TokenType.NOT,
                '?': TokenType.TERNARY_IF, ':': TokenType.TERNARY_ELSE, '.': TokenType.DOT, ',': TokenType.COMMA,
                '(': TokenType.LPAREN, ')': TokenType.RPAREN, '[': TokenType.LBRACKET, ']': TokenType.RBRACKET };
            if (ops[this.current]) {
                const c = this.current; this.advance();
                tokens.push({ type: ops[c], value: c, line, column });
                continue;
            }
            this.advance();
            tokens.push({ type: TokenType.ERROR, value: this.source[this.pos - 1], line, column });
        }
        tokens.push({ type: TokenType.EOF, value: '', line: this.line, column: this.column });
        return tokens;
    }
}

// ============== Parser ==============
class Parser {
    constructor(source) {
        this.tokens = new Lexer(source).tokenize();
        this.pos = 0;
    }

    get current() { return this.tokens[Math.min(this.pos, this.tokens.length - 1)]; }
    advance() { const t = this.current; if (this.pos < this.tokens.length - 1) this.pos++; return t; }
    match(...types) { return types.includes(this.current.type); }
    expect(type, msg) {
        if (this.current.type === type) return this.advance();
        throw new Error(`${msg}, got '${this.current.value}' at ${this.current.line}:${this.current.column}`);
    }

    parse() {
        if (!this.match(TokenType.EXPR_START)) throw new Error("Expression must start with '${' or '#{'");
        const start = this.advance();
        const body = this.parseTernary();
        this.expect(TokenType.EXPR_END, "Expected '}'");
        return { type: 'Expression', body, deferred: start.value.startsWith('#') };
    }

    parseTernary() {
        let cond = this.parseOr();
        if (this.match(TokenType.TERNARY_IF)) {
            this.advance();
            const thenExpr = this.parseTernary();
            this.expect(TokenType.TERNARY_ELSE, "Expected ':' in ternary");
            const elseExpr = this.parseTernary();
            return { type: 'TernaryOp', condition: cond, thenExpr, elseExpr };
        }
        return cond;
    }

    parseOr() {
        let left = this.parseAnd();
        while (this.match(TokenType.OR)) { this.advance(); left = { type: 'BinaryOp', operator: 'or', left, right: this.parseAnd() }; }
        return left;
    }

    parseAnd() {
        let left = this.parseEquality();
        while (this.match(TokenType.AND)) { this.advance(); left = { type: 'BinaryOp', operator: 'and', left, right: this.parseEquality() }; }
        return left;
    }

    parseEquality() {
        let left = this.parseComparison();
        while (this.match(TokenType.EQ, TokenType.NE)) {
            const op = this.advance();
            left = { type: 'BinaryOp', operator: op.type === TokenType.EQ ? '==' : '!=', left, right: this.parseComparison() };
        }
        return left;
    }

    parseComparison() {
        let left = this.parseAdditive();
        while (this.match(TokenType.LT, TokenType.GT, TokenType.LE, TokenType.GE)) {
            const op = this.advance();
            const opMap = { [TokenType.LT]: '<', [TokenType.GT]: '>', [TokenType.LE]: '<=', [TokenType.GE]: '>=' };
            left = { type: 'BinaryOp', operator: opMap[op.type], left, right: this.parseAdditive() };
        }
        return left;
    }

    parseAdditive() {
        let left = this.parseMultiplicative();
        while (this.match(TokenType.PLUS, TokenType.MINUS)) {
            const op = this.advance();
            left = { type: 'BinaryOp', operator: op.type === TokenType.PLUS ? '+' : '-', left, right: this.parseMultiplicative() };
        }
        return left;
    }

    parseMultiplicative() {
        let left = this.parseUnary();
        while (this.match(TokenType.MULTIPLY, TokenType.DIVIDE, TokenType.MODULO)) {
            const op = this.advance();
            const opMap = { [TokenType.MULTIPLY]: '*', [TokenType.DIVIDE]: '/', [TokenType.MODULO]: '%' };
            left = { type: 'BinaryOp', operator: opMap[op.type], left, right: this.parseUnary() };
        }
        return left;
    }

    parseUnary() {
        if (this.match(TokenType.NOT, TokenType.MINUS, TokenType.EMPTY)) {
            const op = this.advance();
            const opMap = { [TokenType.NOT]: 'not', [TokenType.MINUS]: '-', [TokenType.EMPTY]: 'empty' };
            return { type: 'UnaryOp', operator: opMap[op.type], operand: this.parseUnary() };
        }
        return this.parsePostfix();
    }

    parsePostfix() {
        let node = this.parsePrimary();
        while (true) {
            if (this.match(TokenType.DOT)) {
                this.advance();
                const prop = this.expect(TokenType.IDENTIFIER, "Expected property name");
                // Check if this is a method call: obj.method()
                if (this.match(TokenType.LPAREN)) {
                    this.advance();
                    const args = [];
                    if (!this.match(TokenType.RPAREN)) {
                        args.push(this.parseTernary());
                        while (this.match(TokenType.COMMA)) { this.advance(); args.push(this.parseTernary()); }
                    }
                    this.expect(TokenType.RPAREN, "Expected ')'");
                    node = { type: 'MethodCall', object: node, method: prop.value, arguments: args };
                } else {
                    node = { type: 'PropertyAccess', object: node, property: prop.value };
                }
            } else if (this.match(TokenType.LBRACKET)) {
                this.advance();
                const index = this.parseTernary();
                this.expect(TokenType.RBRACKET, "Expected ']'");
                node = { type: 'IndexAccess', object: node, index };
            } else if (this.match(TokenType.LPAREN)) {
                if (node.type !== 'Identifier') throw new Error("Cannot call non-identifier");
                this.advance();
                const args = [];
                if (!this.match(TokenType.RPAREN)) {
                    args.push(this.parseTernary());
                    while (this.match(TokenType.COMMA)) { this.advance(); args.push(this.parseTernary()); }
                }
                this.expect(TokenType.RPAREN, "Expected ')'");
                node = { type: 'FunctionCall', name: node.name, arguments: args };
            } else break;
        }
        return node;
    }

    parsePrimary() {
        const t = this.current;
        if (this.match(TokenType.STRING)) { this.advance(); return { type: 'Literal', value: t.value, litType: 'string' }; }
        if (this.match(TokenType.NUMBER)) { this.advance(); return { type: 'Literal', value: t.value.includes('.') ? parseFloat(t.value) : parseInt(t.value), litType: 'number' }; }
        if (this.match(TokenType.BOOLEAN)) { this.advance(); return { type: 'Literal', value: t.value === 'true', litType: 'boolean' }; }
        if (this.match(TokenType.NULL)) { this.advance(); return { type: 'Literal', value: null, litType: 'null' }; }
        if (this.match(TokenType.IDENTIFIER)) { this.advance(); return { type: 'Identifier', name: t.value }; }
        if (this.match(TokenType.LPAREN)) { this.advance(); const expr = this.parseTernary(); this.expect(TokenType.RPAREN, "Expected ')'"); return expr; }
        throw new Error(`Unexpected token: '${t.value}' at ${t.line}:${t.column}`);
    }
}

// ============== Built-in Functions ==============
const FUNCTIONS = {
    // String matching
    contains: (obj, val) => {
        if (obj == null) return false;
        if (typeof obj === 'string') return obj.includes(String(val));
        if (Array.isArray(obj)) return obj.includes(val);
        if (typeof obj === 'object') return val in obj;
        return false;
    },
    find: (str, pattern) => { if (str == null) return false; try { return new RegExp(pattern).test(str); } catch { return false; } },
    findGroups: (str, pattern) => {
        if (str == null) return null;
        try { const m = str.match(new RegExp(pattern)); return m ? [m[0], ...(m.slice(1))] : null; } catch { return null; }
    },
    matches: (str, pattern) => { if (str == null) return false; try { return new RegExp(pattern).test(str); } catch { return false; } },
    matchesWithRegex: (str, pattern) => { if (str == null) return false; try { return new RegExp('^' + pattern + '$').test(str); } catch { return false; } },

    // String manipulation
    substring: (str, start, end) => {
        if (str == null) return '';
        str = String(str);
        if (end === undefined) return str.substring(start);
        return str.substring(start, end);
    },
    startsWith: (str, prefix) => str == null ? false : String(str).startsWith(String(prefix)),
    endsWith: (str, suffix) => str == null ? false : String(str).endsWith(String(suffix)),
    toLowerCase: (str) => str == null ? '' : String(str).toLowerCase(),
    toUpperCase: (str) => str == null ? '' : String(str).toUpperCase(),
    trim: (str) => str == null ? '' : String(str).trim(),
    trimStart: (str) => str == null ? '' : String(str).trimStart(),
    trimEnd: (str) => str == null ? '' : String(str).trimEnd(),
    replace: (str, search, replacement) => str == null ? '' : String(str).replace(search, replacement),
    replaceAll: (str, search, replacement) => str == null ? '' : String(str).replaceAll(search, replacement),
    concat: (...args) => args.map(a => a == null ? '' : String(a)).join(''),
    charAt: (str, index) => str == null ? '' : String(str).charAt(index),
    charCodeAt: (str, index) => str == null ? 0 : String(str).charCodeAt(index),
    repeat: (str, count) => str == null ? '' : String(str).repeat(count),
    padStart: (str, len, pad) => str == null ? '' : String(str).padStart(len, pad),
    padEnd: (str, len, pad) => str == null ? '' : String(str).padEnd(len, pad),

    // Type conversion
    bool: (val) => val != null && String(val).toLowerCase() === 'true',
    boolean: (val) => val != null && String(val).toLowerCase() === 'true',
    integer: (val, radix = 10) => { const n = parseInt(val, radix); return isNaN(n) ? null : n; },
    number: (val) => { const n = parseFloat(val); return isNaN(n) ? null : n; },
    toString: (val) => val == null ? '' : String(val),

    // Array/Collection functions
    split: (str, pattern, limit) => {
        if (str == null) return [];
        try {
            const regex = new RegExp(pattern);
            return limit !== undefined ? str.split(regex, limit) : str.split(regex);
        } catch { return [str]; }
    },
    join: (vals, sep = '') => vals == null ? '' : Array.isArray(vals) ? vals.join(sep) : String(vals),
    array: (...args) => args,
    first: (arr) => Array.isArray(arr) && arr.length > 0 ? arr[0] : null,
    last: (arr) => Array.isArray(arr) && arr.length > 0 ? arr[arr.length - 1] : null,
    reverse: (arr) => Array.isArray(arr) ? [...arr].reverse() : arr,
    sort: (arr) => Array.isArray(arr) ? [...arr].sort() : arr,
    slice: (arr, start, end) => {
        if (arr == null) return [];
        if (typeof arr === 'string') return end !== undefined ? arr.slice(start, end) : arr.slice(start);
        if (Array.isArray(arr)) return end !== undefined ? arr.slice(start, end) : arr.slice(start);
        return [];
    },

    // Object functions
    keys: (obj) => obj == null ? [] : Object.keys(obj),
    keySet: (obj) => obj == null ? [] : Object.keys(obj),
    values: (obj) => obj == null ? [] : Object.values(obj),
    entries: (obj) => obj == null ? [] : Object.entries(obj),

    // Utility functions
    length: (obj) => {
        if (obj == null) return 0;
        if (typeof obj === 'string' || Array.isArray(obj)) return obj.length;
        if (typeof obj === 'object') return Object.keys(obj).length;
        return 0;
    },
    size: (obj) => FUNCTIONS.length(obj),
    indexOf: (str, sub, fromIndex = 0) => str == null || sub == null ? -1 : String(str).indexOf(sub, fromIndex),
    lastIndexOf: (str, sub, fromIndex) => str == null || sub == null ? -1 : (fromIndex !== undefined ? String(str).lastIndexOf(sub, fromIndex) : String(str).lastIndexOf(sub)),
    empty: (val) => val == null || (typeof val === 'string' && val.length === 0) || (Array.isArray(val) && val.length === 0) || (typeof val === 'object' && Object.keys(val).length === 0),
    isEmpty: (val) => FUNCTIONS.empty(val),
    isNull: (val) => val === null || val === undefined,
    isNotNull: (val) => val !== null && val !== undefined,
    defaultTo: (val, defaultVal) => val == null ? defaultVal : val,
    coalesce: (...args) => args.find(a => a != null) ?? null,

    // Encoding functions
    encodeBase64: (str) => str == null ? '' : btoa(unescape(encodeURIComponent(str))),
    decodeBase64: (str) => { try { return decodeURIComponent(escape(atob(str))); } catch { return ''; } },
    urlEncode: (str) => str == null ? '' : encodeURIComponent(str),
    urlDecode: (str) => { try { return decodeURIComponent(str); } catch { return str; } },
    jsonParse: (str) => { try { return JSON.parse(str); } catch { return null; } },
    jsonStringify: (obj) => { try { return JSON.stringify(obj); } catch { return ''; } },

    // Math functions
    abs: (n) => Math.abs(n),
    ceil: (n) => Math.ceil(n),
    floor: (n) => Math.floor(n),
    round: (n) => Math.round(n),
    min: (...args) => Math.min(...args),
    max: (...args) => Math.max(...args),
    random: () => Math.random(),

    // Date/Time functions (simplified)
    now: () => Date.now(),
    timestamp: () => Math.floor(Date.now() / 1000),

    // Type checking
    typeof: (val) => {
        if (val === null || val === undefined) return 'null';
        if (Array.isArray(val)) return 'array';
        return typeof val;
    },
    isString: (val) => typeof val === 'string',
    isNumber: (val) => typeof val === 'number' && !isNaN(val),
    isBoolean: (val) => typeof val === 'boolean',
    isArray: (val) => Array.isArray(val),
    isObject: (val) => val !== null && typeof val === 'object' && !Array.isArray(val),
};

// ============== Evaluator ==============
class Evaluator {
    constructor(context) { this.context = context; this.traces = []; }

    evaluate(ast) {
        try {
            const value = this.visit(ast);
            return { success: true, value, traces: this.traces };
        } catch (e) {
            return { success: false, error: e.message, traces: this.traces };
        }
    }

    visit(node) {
        switch (node.type) {
            case 'Expression': return this.visit(node.body);
            case 'BinaryOp': return this.visitBinaryOp(node);
            case 'UnaryOp': return this.visitUnaryOp(node);
            case 'TernaryOp': return this.visitTernaryOp(node);
            case 'FunctionCall': return this.visitFunctionCall(node);
            case 'MethodCall': return this.visitMethodCall(node);
            case 'PropertyAccess': return this.visitPropertyAccess(node);
            case 'IndexAccess': return this.visitIndexAccess(node);
            case 'Identifier': return this.visitIdentifier(node);
            case 'Literal': return node.value;
            default: throw new Error(`Unknown node type: ${node.type}`);
        }
    }

    visitBinaryOp(node) {
        const left = this.visit(node.left);
        const right = this.visit(node.right);
        let result;
        switch (node.operator) {
            case 'and': result = Boolean(left) && Boolean(right); break;
            case 'or': result = Boolean(left) || Boolean(right); break;
            case '==': result = left === right; break;
            case '!=': result = left !== right; break;
            case '<': result = left < right; break;
            case '<=': result = left <= right; break;
            case '>': result = left > right; break;
            case '>=': result = left >= right; break;
            case '+': result = (typeof left === 'string' || typeof right === 'string') ? String(left ?? '') + String(right ?? '') : (left ?? 0) + (right ?? 0); break;
            case '-': result = (left ?? 0) - (right ?? 0); break;
            case '*': result = (left ?? 0) * (right ?? 0); break;
            case '/': result = (left ?? 0) / right; break;
            case '%': result = (left ?? 0) % right; break;
            default: throw new Error(`Unknown operator: ${node.operator}`);
        }
        this.traces.push({ node, left, right, result, operator: node.operator });
        return result;
    }

    visitUnaryOp(node) {
        const operand = this.visit(node.operand);
        let result;
        switch (node.operator) {
            case 'not': result = !Boolean(operand); break;
            case '-': result = -(operand ?? 0); break;
            case 'empty': result = operand == null || (operand.length !== undefined && operand.length === 0); break;
            default: throw new Error(`Unknown unary operator: ${node.operator}`);
        }
        this.traces.push({ node, operand, result, operator: node.operator });
        return result;
    }

    visitTernaryOp(node) {
        const cond = this.visit(node.condition);
        return cond ? this.visit(node.thenExpr) : this.visit(node.elseExpr);
    }

    visitFunctionCall(node) {
        const fn = FUNCTIONS[node.name];
        if (!fn) throw new Error(`Unknown function: ${node.name}`);
        const args = node.arguments.map(a => this.visit(a));
        const result = fn(...args);
        this.traces.push({ node, name: node.name, args, result });
        return result;
    }

    visitMethodCall(node) {
        const obj = this.visit(node.object);
        const args = node.arguments.map(a => this.visit(a));
        const method = node.method;
        let result;

        // String methods
        const STRING_METHODS = {
            length: (s) => s == null ? 0 : String(s).length,
            toLowerCase: (s) => s == null ? '' : String(s).toLowerCase(),
            toUpperCase: (s) => s == null ? '' : String(s).toUpperCase(),
            trim: (s) => s == null ? '' : String(s).trim(),
            trimStart: (s) => s == null ? '' : String(s).trimStart(),
            trimEnd: (s) => s == null ? '' : String(s).trimEnd(),
            substring: (s, start, end) => s == null ? '' : (end !== undefined ? String(s).substring(start, end) : String(s).substring(start)),
            substr: (s, start, len) => s == null ? '' : (len !== undefined ? String(s).substr(start, len) : String(s).substr(start)),
            charAt: (s, i) => s == null ? '' : String(s).charAt(i),
            charCodeAt: (s, i) => s == null ? 0 : String(s).charCodeAt(i),
            indexOf: (s, sub, from) => s == null ? -1 : (from !== undefined ? String(s).indexOf(sub, from) : String(s).indexOf(sub)),
            lastIndexOf: (s, sub, from) => s == null ? -1 : (from !== undefined ? String(s).lastIndexOf(sub, from) : String(s).lastIndexOf(sub)),
            startsWith: (s, prefix) => s == null ? false : String(s).startsWith(prefix),
            endsWith: (s, suffix) => s == null ? false : String(s).endsWith(suffix),
            includes: (s, sub) => s == null ? false : String(s).includes(sub),
            contains: (s, sub) => s == null ? false : String(s).includes(sub),
            split: (s, sep, limit) => s == null ? [] : (limit !== undefined ? String(s).split(sep, limit) : String(s).split(sep)),
            replace: (s, search, repl) => s == null ? '' : String(s).replace(search, repl),
            replaceAll: (s, search, repl) => s == null ? '' : String(s).replaceAll(search, repl),
            repeat: (s, count) => s == null ? '' : String(s).repeat(count),
            padStart: (s, len, pad) => s == null ? '' : String(s).padStart(len, pad || ' '),
            padEnd: (s, len, pad) => s == null ? '' : String(s).padEnd(len, pad || ' '),
            concat: (s, ...more) => s == null ? '' : String(s).concat(...more),
            match: (s, pattern) => { try { return s == null ? null : String(s).match(new RegExp(pattern)); } catch { return null; } },
            toString: (s) => s == null ? '' : String(s),
        };

        // Array methods
        const ARRAY_METHODS = {
            length: (a) => a == null ? 0 : a.length,
            size: (a) => a == null ? 0 : a.length,
            first: (a) => a == null || a.length === 0 ? null : a[0],
            last: (a) => a == null || a.length === 0 ? null : a[a.length - 1],
            get: (a, i) => a == null ? null : a[i],
            indexOf: (a, val) => a == null ? -1 : a.indexOf(val),
            contains: (a, val) => a == null ? false : a.includes(val),
            includes: (a, val) => a == null ? false : a.includes(val),
            join: (a, sep) => a == null ? '' : a.join(sep ?? ''),
            slice: (a, start, end) => a == null ? [] : (end !== undefined ? a.slice(start, end) : a.slice(start)),
            reverse: (a) => a == null ? [] : [...a].reverse(),
            sort: (a) => a == null ? [] : [...a].sort(),
            isEmpty: (a) => a == null || a.length === 0,
        };

        // Object/Map methods
        const OBJECT_METHODS = {
            keys: (o) => o == null ? [] : Object.keys(o),
            keySet: (o) => o == null ? [] : Object.keys(o),
            values: (o) => o == null ? [] : Object.values(o),
            entries: (o) => o == null ? [] : Object.entries(o),
            size: (o) => o == null ? 0 : Object.keys(o).length,
            get: (o, key) => o == null ? null : o[key],
            containsKey: (o, key) => o == null ? false : key in o,
            containsValue: (o, val) => o == null ? false : Object.values(o).includes(val),
            isEmpty: (o) => o == null || Object.keys(o).length === 0,
        };

        // Try to find and execute the method
        if (typeof obj === 'string' && STRING_METHODS[method]) {
            result = STRING_METHODS[method](obj, ...args);
        } else if (Array.isArray(obj) && ARRAY_METHODS[method]) {
            result = ARRAY_METHODS[method](obj, ...args);
        } else if (obj !== null && typeof obj === 'object' && OBJECT_METHODS[method]) {
            result = OBJECT_METHODS[method](obj, ...args);
        } else if (obj != null && typeof obj[method] === 'function') {
            // Try native method
            result = obj[method](...args);
        } else if (FUNCTIONS[method]) {
            // Fall back to global function with obj as first argument
            result = FUNCTIONS[method](obj, ...args);
        } else {
            throw new Error(`Unknown method: ${method}`);
        }

        this.traces.push({ node, object: obj, method, args, result });
        return result;
    }

    visitPropertyAccess(node) {
        const obj = this.visit(node.object);
        if (obj == null) return null;
        // Special handling for .length property on strings/arrays
        if (node.property === 'length' && (typeof obj === 'string' || Array.isArray(obj))) {
            return obj.length;
        }
        return obj[node.property];
    }

    visitIndexAccess(node) {
        const obj = this.visit(node.object);
        const index = this.visit(node.index);
        if (obj == null) return null;
        return obj[index];
    }

    visitIdentifier(node) {
        return this.context[node.name];
    }
}

// ============== Diagnoser ==============
function diagnose(condition, request) {
    // Parse form data if content-type is application/x-www-form-urlencoded
    const parseFormData = (body, contentType) => {
        if (!body || !contentType) return {};
        if (contentType.includes('application/x-www-form-urlencoded')) {
            return parseQueryParams(body);
        }
        return {};
    };

    const contentType = request.headers['Content-Type']?.[0] || request.headers['content-type']?.[0] || '';
    const formData = parseFormData(request.body, contentType);

    // Build comprehensive context matching IG's runtime
    const context = {
        // Main request object
        request: {
            method: request.method,
            uri: {
                scheme: 'https',
                host: request.host,
                port: 443,
                path: request.path,
                query: request.query,
                fragment: '',
                // Full URL reconstruction
                toString: () => `https://${request.host}${request.path}${request.query ? '?' + request.query : ''}`,
            },
            headers: request.headers,
            cookies: request.cookies,
            form: formData,
            entity: {
                string: request.body,
                json: (() => { try { return JSON.parse(request.body); } catch { return null; } })(),
                bytes: request.body ? new TextEncoder().encode(request.body) : null,
            },
            queryParams: parseQueryParams(request.query),
        },

        // Session object (simulated)
        session: {
            // Common session properties
            sessionId: 'simulated-session-id',
            // Session can store arbitrary properties
        },

        // Attributes (request-scoped storage)
        attributes: {
            // Attributes can store arbitrary properties
        },

        // Contexts object (IG-specific)
        contexts: {
            // Router context
            router: {
                name: 'default',
                baseUri: '/',
            },
            // Client context (info about client connection)
            client: {
                remoteAddress: '127.0.0.1',
                remotePort: 12345,
                localAddress: '127.0.0.1',
                localPort: 443,
                isSecure: true,
                certificates: [],
            },
            // OAuth2 context (if present)
            oauth2: {
                accessToken: null,
                tokenInfo: {},
            },
            // AM (Access Management) context
            amSession: {
                sessionId: null,
                realm: '/',
                username: null,
            },
            // JWT context
            jwtSession: {
                claims: {},
            },
        },

        // Environment variables
        env: {
            // System environment variables can be accessed here
        },

        // System properties
        system: {
            // Java system properties (simulated)
        },

        // Heap storage (cross-request)
        heap: {},

        // True/false/null literals for convenience
        true: true,
        false: false,
        null: null,
    };

    let ast;
    try {
        ast = new Parser(condition).parse();
    } catch (e) {
        return { success: false, error: e.message, conditions: [] };
    }

    const evaluator = new Evaluator(context);
    const result = evaluator.evaluate(ast);

    if (!result.success) {
        return { success: false, error: result.error, conditions: [] };
    }

    const conditions = analyzeConditions(ast.body, context);
    const passed = conditions.filter(c => c.passed).length;

    return {
        success: true,
        overall: Boolean(result.value),
        conditions,
        summary: `${passed}/${conditions.length} conditions passed`
    };
}

function analyzeConditions(node, context, depth = 0) {
    const results = [];

    if (node.type === 'BinaryOp' && node.operator === 'and') {
        // AND: expand as independent conditions
        results.push(...analyzeConditions(node.left, context, depth));
        results.push(...analyzeConditions(node.right, context, depth));
    } else if (node.type === 'BinaryOp' && node.operator === 'or') {
        // OR: treat as a group, show each branch
        const evaluator = new Evaluator(context);
        const value = evaluator.visit(node);
        const branches = collectOrBranches(node);
        const branchResults = branches.map(b => {
            const branchEval = new Evaluator(context);
            const branchValue = branchEval.visit(b);
            // For AND expressions, collect details from sub-conditions
            const subDetails = collectSubDetails(b, context);
            const details = generateDetails(b, branchValue, context);
            return {
                expression: nodeToString(b),
                passed: Boolean(branchValue),
                details: details.details,
                suggestion: details.suggestion,
                subDetails: subDetails
            };
        });

        results.push({
            expression: nodeToString(node),
            passed: Boolean(value),
            value,
            isOrGroup: true,
            branches: branchResults,
            details: `OR group: ${branchResults.filter(b => b.passed).length}/${branchResults.length} branches match`,
            suggestion: ''
        });
    } else {
        const evaluator = new Evaluator(context);
        const value = evaluator.visit(node);
        const exprStr = nodeToString(node);
        const details = generateDetails(node, value, context);

        results.push({
            expression: exprStr,
            passed: Boolean(value),
            value,
            details: details.details,
            suggestion: details.suggestion
        });
    }

    return results;
}

function collectOrBranches(node) {
    if (node.type === 'BinaryOp' && node.operator === 'or') {
        return [...collectOrBranches(node.left), ...collectOrBranches(node.right)];
    }
    return [node];
}

// Collect detailed info from sub-conditions (for AND expressions)
function collectSubDetails(node, context) {
    const results = [];

    function collect(n) {
        if (n.type === 'BinaryOp' && n.operator === 'and') {
            collect(n.left);
            collect(n.right);
        } else if (n.type === 'BinaryOp' && n.operator === 'or') {
            // OR chain - collect all branches and show as a group
            const orBranches = collectOrBranches(n);
            const evaluator = new Evaluator(context);
            const overallValue = evaluator.visit(n);

            // Find which branch matched (if any)
            const branchResults = orBranches.map(b => {
                const branchEval = new Evaluator(context);
                const value = branchEval.visit(b);
                return {
                    expression: nodeToString(b),
                    passed: Boolean(value),
                    node: b
                };
            });

            const passedBranch = branchResults.find(b => b.passed);

            // Create a summary for the OR group
            let orSummary;
            if (passedBranch) {
                // Show which one matched
                const details = generateDetails(passedBranch.node, true, context);
                orSummary = {
                    expression: `OR (${branchResults.length} options)`,
                    passed: true,
                    details: details.details,
                    matchedPattern: getShortDescFromNode(passedBranch.node)
                };
            } else {
                orSummary = {
                    expression: `OR (${branchResults.length} options)`,
                    passed: false,
                    details: `None of ${branchResults.length} patterns matched`
                };
            }
            results.push(orSummary);
        } else if (n.type === 'FunctionCall' || n.type === 'MethodCall') {
            const evaluator = new Evaluator(context);
            const value = evaluator.visit(n);
            const details = generateDetails(n, value, context);
            results.push({
                expression: nodeToString(n),
                passed: Boolean(value),
                details: details.details
            });
        } else if (n.type === 'BinaryOp') {
            // Comparison operators
            const evaluator = new Evaluator(context);
            const value = evaluator.visit(n);
            const details = generateDetails(n, value, context);
            results.push({
                expression: nodeToString(n),
                passed: Boolean(value),
                details: details.details
            });
        }
    }

    collect(node);
    return results;
}

// Helper to get short description from AST node
function getShortDescFromNode(node) {
    if (node.type === 'FunctionCall' && node.arguments.length >= 2) {
        const arg = node.arguments[1];
        if (arg.type === 'Literal' && arg.litType === 'string') {
            const val = arg.value;
            return val.length > 50 ? val.slice(0, 47) + '...' : val;
        }
    }
    const expr = nodeToString(node);
    return expr.length > 50 ? expr.slice(0, 47) + '...' : expr;
}

function nodeToString(node, parentOp = null) {
    switch (node.type) {
        case 'BinaryOp': {
            const inner = `${nodeToString(node.left, node.operator)} ${node.operator} ${nodeToString(node.right, node.operator)}`;
            // Only add parens if parent has different precedence
            const needsParens = parentOp && parentOp !== node.operator &&
                ((parentOp === 'and' && node.operator === 'or') || (parentOp === 'or' && node.operator === 'and'));
            return needsParens ? `(${inner})` : inner;
        }
        case 'UnaryOp': return `${node.operator} ${nodeToString(node.operand)}`;
        case 'FunctionCall': return `${node.name}(${node.arguments.map(a => nodeToString(a)).join(', ')})`;
        case 'MethodCall': return `${nodeToString(node.object)}.${node.method}(${node.arguments.map(a => nodeToString(a)).join(', ')})`;
        case 'PropertyAccess': return `${nodeToString(node.object)}.${node.property}`;
        case 'IndexAccess': return `${nodeToString(node.object)}[${nodeToString(node.index)}]`;
        case 'Identifier': return node.name;
        case 'Literal': return node.litType === 'string' ? `'${node.value}'` : String(node.value);
        case 'Ternary': return `${nodeToString(node.condition)} ? ${nodeToString(node.consequent)} : ${nodeToString(node.alternate)}`;
        default: return '?';
    }
}

function generateDetails(node, value, context) {
    let details = '', suggestion = '';

    // Helper to escape HTML
    const esc = (s) => String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

    // Helper to format value with highlighting
    const hval = (val) => {
        if (val === true) return '<span class="val-true">true</span>';
        if (val === false) return '<span class="val-false">false</span>';
        if (val === null || val === undefined) return '<span class="val-false">null</span>';
        if (typeof val === 'string') return `<span class="fn-arg">"${esc(val)}"</span>`;
        if (typeof val === 'number') return `<span class="fn-result">${val}</span>`;
        if (Array.isArray(val)) return `<span class="fn-arg">${esc(JSON.stringify(val))}</span>`;
        if (typeof val === 'object') return `<span class="fn-arg">${esc(JSON.stringify(val))}</span>`;
        return esc(String(val));
    };

    if (node.type === 'BinaryOp') {
        const leftVal = new Evaluator(context).visit(node.left);
        const rightVal = new Evaluator(context).visit(node.right);

        if (node.operator === 'and' || node.operator === 'or') {
            // For logical operators, show which side(s) failed/passed
            const leftBool = Boolean(leftVal);
            const rightBool = Boolean(rightVal);
            const opHtml = `<span class="op">${node.operator}</span>`;
            if (node.operator === 'and') {
                if (!leftBool && !rightBool) {
                    details = `${hval(false)} ${opHtml} ${hval(false)} → Both conditions are false`;
                } else if (!leftBool) {
                    details = `${hval(false)} ${opHtml} ${hval(true)} → Left condition is false`;
                } else if (!rightBool) {
                    details = `${hval(true)} ${opHtml} ${hval(false)} → Right condition is false`;
                } else {
                    details = `${hval(true)} ${opHtml} ${hval(true)} → Both conditions are true`;
                }
            } else { // or
                if (leftBool || rightBool) {
                    details = `${hval(leftBool)} ${opHtml} ${hval(rightBool)} → ${leftBool ? 'Left' : 'Right'} condition is true`;
                } else {
                    details = `${hval(false)} ${opHtml} ${hval(false)} → Both conditions are false`;
                }
            }
        } else {
            // For comparison operators, show actual values
            const opHtml = `<span class="op">${esc(node.operator)}</span>`;
            details = `${hval(leftVal)} ${opHtml} ${hval(rightVal)}`;
            if (node.operator === '==' && leftVal !== rightVal) {
                suggestion = `Expected ${hval(rightVal)}, but got ${hval(leftVal)}`;
            }
        }
    } else if (node.type === 'FunctionCall') {
        const args = node.arguments.map(a => new Evaluator(context).visit(a));
        const fnName = `<span class="fn-name">${esc(node.name)}</span>`;
        const resultHtml = hval(value);

        // For string matching functions, highlight the matched portion
        const matchFuncs = ['matches', 'contains', 'find', 'matchesWithRegex', 'findGroups', 'startsWith', 'endsWith'];
        if (matchFuncs.includes(node.name) && args.length >= 2) {
            const haystack = String(args[0] || '');
            const needle = String(args[1] || '');
            const matched = value && (typeof value === 'boolean' ? value : value !== null);

            if (matched && needle) {
                // Match found - highlight the matched portion
                let highlightedHaystack;
                try {
                    if (node.name === 'contains') {
                        // Simple substring match
                        const idx = haystack.indexOf(needle);
                        if (idx >= 0) {
                            const before = esc(haystack.slice(0, idx));
                            const match = esc(haystack.slice(idx, idx + needle.length));
                            const after = esc(haystack.slice(idx + needle.length));
                            highlightedHaystack = `<span class="fn-arg">"${before}<span class="match-highlight">${match}</span>${after}"</span>`;
                        } else {
                            highlightedHaystack = hval(haystack);
                        }
                    } else if (node.name === 'startsWith') {
                        // Prefix match
                        if (haystack.startsWith(needle)) {
                            const match = esc(needle);
                            const after = esc(haystack.slice(needle.length));
                            highlightedHaystack = `<span class="fn-arg">"<span class="match-highlight">${match}</span>${after}"</span>`;
                        } else {
                            highlightedHaystack = hval(haystack);
                        }
                    } else if (node.name === 'endsWith') {
                        // Suffix match
                        if (haystack.endsWith(needle)) {
                            const before = esc(haystack.slice(0, -needle.length));
                            const match = esc(needle);
                            highlightedHaystack = `<span class="fn-arg">"${before}<span class="match-highlight">${match}</span>"</span>`;
                        } else {
                            highlightedHaystack = hval(haystack);
                        }
                    } else if (node.name === 'matchesWithRegex') {
                        // Full regex match - the entire string should match
                        const regex = new RegExp('^' + needle + '$');
                        if (regex.test(haystack)) {
                            highlightedHaystack = `<span class="fn-arg">"<span class="match-highlight">${esc(haystack)}</span>"</span>`;
                        } else {
                            highlightedHaystack = hval(haystack);
                        }
                    } else {
                        // Regex match (matches/find/findGroups)
                        const regex = new RegExp(needle);
                        const match = haystack.match(regex);
                        if (match && match[0]) {
                            const idx = haystack.indexOf(match[0]);
                            const before = esc(haystack.slice(0, idx));
                            const matchStr = esc(match[0]);
                            const after = esc(haystack.slice(idx + match[0].length));
                            highlightedHaystack = `<span class="fn-arg">"${before}<span class="match-highlight">${matchStr}</span>${after}"</span>`;
                        } else {
                            highlightedHaystack = hval(haystack);
                        }
                    }
                } catch (e) {
                    highlightedHaystack = hval(haystack);
                }
                details = `${fnName}(${highlightedHaystack}, ${hval(needle)}) → ${resultHtml}`;
            } else {
                // No match
                details = `${fnName}(${hval(haystack)}, ${hval(needle)}) → ${resultHtml}`;
                suggestion = `Pattern ${hval(needle)} not found in ${hval(haystack)}`;
            }
        } else {
            const argsHtml = args.map(hval).join(', ');
            details = `${fnName}(${argsHtml}) → ${resultHtml}`;
        }
    } else if (node.type === 'UnaryOp') {
        const operand = new Evaluator(context).visit(node.operand);
        const opHtml = `<span class="op">${esc(node.operator)}</span>`;
        details = `${opHtml} ${hval(operand)} → ${hval(value)}`;
    }

    return { details, suggestion, isHtml: true };
}

function repr(val) {
    if (val === null || val === undefined) return 'null';
    if (typeof val === 'string') return `"${val}"`;
    if (typeof val === 'boolean') return val ? 'true' : 'false';
    if (Array.isArray(val)) return JSON.stringify(val);
    if (typeof val === 'object') return JSON.stringify(val);
    return String(val);
}

function parseQueryParams(query) {
    if (!query) return {};
    const params = {};
    query.split('&').forEach(pair => {
        const [key, value] = pair.split('=');
        if (key) {
            if (!params[key]) params[key] = [];
            params[key].push(decodeURIComponent(value || ''));
        }
    });
    return params;
}

function parseCurl(curlCmd) {
    const request = { method: 'GET', path: '/', query: '', host: '', headers: {}, cookies: {}, body: null };
    const cleaned = curlCmd.replace(/\\\n/g, ' ').replace(/\s+/g, ' ').trim();

    // Check if input is just a URL (not a curl command)
    if (cleaned.match(/^https?:\/\/[^\s]+$/) && !cleaned.startsWith('curl')) {
        return parseUrl(cleaned);
    }

    const args = [];
    let current = '', inQuote = null;

    for (let i = 0; i < cleaned.length; i++) {
        const c = cleaned[i];
        if (inQuote) {
            if (c === inQuote) inQuote = null;
            else current += c;
        } else if (c === '"' || c === "'") {
            inQuote = c;
        } else if (c === ' ') {
            if (current) { args.push(current); current = ''; }
        } else {
            current += c;
        }
    }
    if (current) args.push(current);

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (arg === '-X' || arg === '--request') { request.method = args[++i]?.toUpperCase() || 'GET'; }
        else if (arg === '-H' || arg === '--header') {
            const header = args[++i] || '';
            const idx = header.indexOf(':');
            if (idx > 0) {
                const name = header.slice(0, idx).trim();
                const value = header.slice(idx + 1).trim();
                if (!request.headers[name]) request.headers[name] = [];
                request.headers[name].push(value);
            }
        }
        else if (arg === '-d' || arg === '--data' || arg === '--data-raw') {
            request.body = args[++i] || '';
            if (request.method === 'GET') request.method = 'POST';
        }
        else if (arg.startsWith('http://') || arg.startsWith('https://')) {
            const parsed = parseUrl(arg);
            request.host = parsed.host;
            request.path = parsed.path;
            request.query = parsed.query;
        }
    }
    return request;
}

function parseUrl(urlStr) {
    const request = { method: 'GET', path: '/', query: '', host: '', headers: {}, cookies: {}, body: null };
    try {
        const url = new URL(urlStr);
        request.host = url.hostname;
        // Query string: decode it so conditions can match actual values
        // e.g., %3CAdvices%3E becomes <Advices>
        const rawQuery = url.search ? url.search.slice(1) : '';
        try {
            request.query = decodeURIComponent(rawQuery);
        } catch (e) {
            // If decoding fails (malformed %), keep original
            request.query = rawQuery;
        }
        // Path: decode it (IG's request.uri.path is decoded)
        // url.pathname is already decoded by the URL parser
        request.path = url.pathname || '/';
    } catch (e) {
        console.error('Failed to parse URL:', e);
    }
    return request;
}

// ============== UI ==============
document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
        tab.classList.add('active');
        document.getElementById('tab-' + tab.dataset.tab).classList.remove('hidden');
    });
});

document.getElementById('add-header').addEventListener('click', () => {
    const list = document.getElementById('headers-list');
    const row = document.createElement('div');
    row.className = 'header-row';

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.placeholder = 'Header name';
    nameInput.className = 'header-name';

    const valueInput = document.createElement('input');
    valueInput.type = 'text';
    valueInput.placeholder = 'Header value';
    valueInput.className = 'header-value';

    const removeBtn = document.createElement('button');
    removeBtn.className = 'btn-icon remove-header';
    removeBtn.textContent = '×';

    row.appendChild(nameInput);
    row.appendChild(valueInput);
    row.appendChild(removeBtn);
    list.appendChild(row);
});

document.getElementById('headers-list').addEventListener('click', e => {
    if (e.target.classList.contains('remove-header')) {
        if (document.querySelectorAll('.header-row').length > 1) e.target.parentElement.remove();
    }
});

document.getElementById('parse-curl').addEventListener('click', () => {
    const curl = document.getElementById('curl-input').value;
    if (!curl) return;
    const req = parseCurl(curl);
    document.getElementById('method').value = req.method;
    document.getElementById('path').value = req.path;
    document.getElementById('query').value = req.query;
    document.getElementById('host').value = req.host;
    document.getElementById('body').value = req.body || '';

    const list = document.getElementById('headers-list');
    list.textContent = '';
    const entries = Object.entries(req.headers);
    if (entries.length === 0) {
        addHeaderRow('', '');
    } else {
        entries.forEach(([name, values]) => addHeaderRow(name, values[0]));
    }
    document.querySelector('[data-tab="manual"]').click();
});

function addHeaderRow(name, value) {
    const list = document.getElementById('headers-list');
    const row = document.createElement('div');
    row.className = 'header-row';

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.placeholder = 'Header name';
    nameInput.className = 'header-name';
    nameInput.value = name;

    const valueInput = document.createElement('input');
    valueInput.type = 'text';
    valueInput.placeholder = 'Header value';
    valueInput.className = 'header-value';
    valueInput.value = value;

    const removeBtn = document.createElement('button');
    removeBtn.className = 'btn-icon remove-header';
    removeBtn.textContent = '×';

    row.appendChild(nameInput);
    row.appendChild(valueInput);
    row.appendChild(removeBtn);
    list.appendChild(row);
}

document.getElementById('diagnose-btn').addEventListener('click', () => {
    const condition = document.getElementById('condition').value;
    if (!condition) { alert('Please enter a condition'); return; }

    // Check if currently on cURL tab, if so and has content, parse first
    const curlTab = document.querySelector('[data-tab="curl"]');
    if (curlTab.classList.contains('active')) {
        const curl = document.getElementById('curl-input').value;
        if (curl) {
            const req = parseCurl(curl);
            document.getElementById('method').value = req.method;
            document.getElementById('path').value = req.path;
            document.getElementById('query').value = req.query;
            document.getElementById('host').value = req.host;
            document.getElementById('body').value = req.body || '';

            const list = document.getElementById('headers-list');
            list.textContent = '';
            const entries = Object.entries(req.headers);
            if (entries.length === 0) {
                addHeaderRow('', '');
            } else {
                entries.forEach(([name, values]) => addHeaderRow(name, values[0]));
            }
        }
    }

    const headers = {};
    document.querySelectorAll('.header-row').forEach(row => {
        const name = row.querySelector('.header-name').value.trim();
        const value = row.querySelector('.header-value').value;
        if (name) {
            if (!headers[name]) headers[name] = [];
            headers[name].push(value);
        }
    });

    const request = {
        method: document.getElementById('method').value,
        path: document.getElementById('path').value,
        query: document.getElementById('query').value,
        host: document.getElementById('host').value,
        headers,
        cookies: {},
        body: document.getElementById('body').value || null
    };

    const result = diagnose(condition, request);
    displayResult(result);
});

function displayResult(result) {
    const container = document.getElementById('result-container');
    container.textContent = '';

    if (!result.success) {
        container.appendChild(createHeader('error', '⚠️', 'Error', result.error));
        return;
    }

    const type = result.overall ? 'passed' : 'failed';
    const icon = result.overall ? '✓' : '✗';
    const status = result.overall ? 'PASSED' : 'FAILED';
    container.appendChild(createHeader(type, icon, status, result.summary));

    if (result.conditions.length > 0) {
        const list = document.createElement('div');
        list.className = 'condition-list';
        result.conditions.forEach((c, idx) => list.appendChild(createConditionItem(c, idx + 1, result.conditions.length)));
        container.appendChild(list);
    }
}

function createHeader(type, icon, title, msg) {
    const div = document.createElement('div');
    div.className = 'result-header result-' + type;

    const iconSpan = document.createElement('span');
    iconSpan.className = 'result-icon';
    iconSpan.textContent = icon;

    const content = document.createElement('div');
    const titleEl = document.createElement('strong');
    titleEl.textContent = title;
    const msgEl = document.createElement('div');
    msgEl.style.cssText = 'font-size:0.9rem;margin-top:0.25rem';
    msgEl.textContent = msg;

    content.appendChild(titleEl);
    content.appendChild(msgEl);
    div.appendChild(iconSpan);
    div.appendChild(content);
    return div;
}

// Helper to create a collapsible section
function createCollapsible(headerContent, detailsContent, startExpanded = false) {
    const wrapper = document.createElement('div');

    const header = document.createElement('div');
    header.className = 'collapsible' + (startExpanded ? ' expanded' : '');
    if (typeof headerContent === 'string') {
        header.innerHTML = headerContent;
    } else {
        header.appendChild(headerContent);
    }

    const content = document.createElement('div');
    content.className = 'collapse-content' + (startExpanded ? ' show' : '');
    if (typeof detailsContent === 'string') {
        content.innerHTML = detailsContent;
    } else {
        content.appendChild(detailsContent);
    }

    header.addEventListener('click', () => {
        header.classList.toggle('expanded');
        content.classList.toggle('show');
    });

    wrapper.appendChild(header);
    wrapper.appendChild(content);
    return wrapper;
}

// Extract short description from expression (e.g., get the pattern from matches())
function getShortDesc(expr, asHtml = false) {
    // For matches/contains, extract the function name and pattern
    const matchResult = expr.match(/(?:(matches|matchesWithRegex|contains|find|findGroups|startsWith|endsWith))\s*\([^,]+,\s*['"]([^'"]+)['"]\)/);
    if (matchResult) {
        const fnName = matchResult[1];
        const pattern = matchResult[2];
        const truncatedPattern = pattern.length > 50 ? pattern.slice(0, 47) + '...' : pattern;
        if (asHtml) {
            return `<span class="fn-name">${escapeHtml(fnName)}</span>(<span class="pattern-highlight">${escapeHtml(truncatedPattern)}</span>)`;
        }
        return truncatedPattern;
    }
    // For other expressions, truncate
    const truncated = expr.length > 60 ? expr.slice(0, 57) + '...' : expr;
    return asHtml ? escapeHtml(truncated) : truncated;
}

function createConditionItem(c, index, total) {
    const div = document.createElement('div');
    div.className = 'condition-item ' + (c.passed ? 'passed' : 'failed');

    const statusIcon = c.passed ? '✓' : '✗';
    const statusColor = c.passed ? '#10b981' : '#ef4444';

    // Show index if there are multiple conditions at root level
    const indexLabel = (total && total > 1) ? `<strong style="color:#94a3b8">${index}.</strong> ` : '';

    if (c.isOrGroup) {
        // OR Group - show summary
        const passedCount = c.branches.filter(b => b.passed).length;
        const totalCount = c.branches.length;

        // Find which branch passed (if any)
        const passedBranch = c.branches.find(b => b.passed);
        let summaryText = `${passedCount}/${totalCount} branches match`;
        let matchedPatternsHtml = '';
        if (passedBranch && passedBranch.subDetails && passedBranch.subDetails.length > 0) {
            // Show what matched with highlighting
            const matchedPatternsArr = passedBranch.subDetails
                .filter(s => s.passed)
                .map(s => getShortDesc(s.expression, true))
                .slice(0, 2);
            if (matchedPatternsArr.length > 0) {
                matchedPatternsHtml = ` — matched: ${matchedPatternsArr.join(', ')}`;
            }
        }

        const headerHtml = `${indexLabel}<span style="color:${statusColor}">${statusIcon}</span> <strong>OR</strong> <span style="color:#94a3b8;font-size:0.85rem">${summaryText}</span>${matchedPatternsHtml}`;

        // Details: list each branch simply
        const detailsDiv = document.createElement('div');
        detailsDiv.style.cssText = 'padding-left: 1rem; margin-top: 0.5rem;';

        c.branches.forEach((branch, idx) => {
            const branchItem = createBranchItem(branch, idx + 1);
            detailsDiv.appendChild(branchItem);
        });

        const collapsible = createCollapsible(headerHtml, detailsDiv, false);
        div.appendChild(collapsible);

    } else {
        // Single condition
        const shortExprHtml = getShortDesc(c.expression, true);
        const hasDetails = c.details || (c.suggestion && !c.passed);

        if (hasDetails) {
            const headerHtml = `${indexLabel}<span style="color:${statusColor}">${statusIcon}</span> <code style="font-size:0.85rem;color:#e2e8f0">${shortExprHtml}</code> → <span class="${c.passed ? 'val-true' : 'val-false'}">${c.passed}</span>`;

            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'condition-details';
            detailsDiv.style.cssText = 'padding-left: 1.5rem; margin-top: 0.5rem;';

            if (c.details) {
                const det = document.createElement('div');
                det.innerHTML = c.details;
                detailsDiv.appendChild(det);
            }

            if (c.suggestion && !c.passed) {
                const sug = document.createElement('div');
                sug.className = 'condition-suggestion';
                sug.innerHTML = '💡 ' + c.suggestion;
                detailsDiv.appendChild(sug);
            }

            const collapsible = createCollapsible(headerHtml, detailsDiv, false);
            div.appendChild(collapsible);
        } else {
            const expr = document.createElement('div');
            expr.className = 'condition-expr';
            expr.innerHTML = `${indexLabel}<span style="color:${statusColor}">${statusIcon}</span> <code style="font-size:0.85rem">${shortExprHtml}</code> → <span class="${c.passed ? 'val-true' : 'val-false'}">${c.passed}</span>`;
            div.appendChild(expr);
        }
    }

    return div;
}

// Create a branch item (for OR group branches)
function createBranchItem(branch, index) {
    const branchDiv = document.createElement('div');
    branchDiv.style.cssText = 'margin: 0.25rem 0; padding: 0.5rem; background: #1e293b; border-radius: 4px;';

    const statusIcon = branch.passed ? '✓' : '○';
    const statusColor = branch.passed ? '#10b981' : '#64748b';

    // Determine branch type and create concise summary
    let branchSummary;
    if (branch.subDetails && branch.subDetails.length > 0) {
        // AND condition with multiple parts
        const passedSubs = branch.subDetails.filter(s => s.passed);
        const patterns = branch.subDetails.map(s => ({
            patternHtml: getShortDesc(s.expression, true),
            passed: s.passed
        }));

        // Show patterns with their status
        branchSummary = patterns.map(p =>
            `<span style="color:${p.passed ? '#10b981' : '#64748b'}">${p.passed ? '✓' : '✗'}</span> ${p.patternHtml}`
        ).join('<br>');
    } else {
        branchSummary = `<code style="font-size:0.8rem">${getShortDesc(branch.expression, true)}</code>`;
    }

    const hasDetails = (branch.subDetails && branch.subDetails.length > 0);

    if (hasDetails) {
        // Count passed sub-conditions
        const passedCount = branch.subDetails.filter(s => s.passed).length;
        const totalCount = branch.subDetails.length;

        // Show relationship summary like "AND 2/2 conditions"
        let headerHtml;
        if (totalCount > 1) {
            headerHtml = `<span style="color:${statusColor}">${statusIcon}</span> <strong style="color:#94a3b8">Branch ${index}</strong> <strong class="op">AND</strong> <span style="color:#94a3b8;font-size:0.85rem">${passedCount}/${totalCount} conditions match</span> → <span class="${branch.passed ? 'val-true' : 'val-false'}">${branch.passed}</span>`;
        } else {
            headerHtml = `<span style="color:${statusColor}">${statusIcon}</span> <strong style="color:#94a3b8">Branch ${index}</strong> → <span class="${branch.passed ? 'val-true' : 'val-false'}">${branch.passed}</span>`;
        }

        const detailsDiv = document.createElement('div');
        detailsDiv.style.cssText = 'padding-left: 1rem; margin-top: 0.5rem;';

        // Show each sub-condition
        branch.subDetails.forEach((sub, idx) => {
            const subItem = createSubDetailItem(sub);
            detailsDiv.appendChild(subItem);
        });

        const collapsible = createCollapsible(headerHtml, detailsDiv, false);
        branchDiv.appendChild(collapsible);
    } else {
        branchDiv.innerHTML = `<span style="color:${statusColor}">${statusIcon}</span> <code style="font-size:0.8rem;color:#e2e8f0">${getShortDesc(branch.expression, true)}</code> → <span class="${branch.passed ? 'val-true' : 'val-false'}">${branch.passed}</span>`;
    }

    return branchDiv;
}

// Create a sub-detail item (for individual function calls)
function createSubDetailItem(sub) {
    const subDiv = document.createElement('div');
    subDiv.style.cssText = 'margin: 0.25rem 0;';

    const statusIcon = sub.passed ? '✓' : '○';
    const statusColor = sub.passed ? '#10b981' : '#64748b';
    const patternHtml = getShortDesc(sub.expression, true);

    if (sub.details) {
        const headerHtml = `<span style="color:${statusColor}">${statusIcon}</span> <code style="font-size:0.8rem;color:#e2e8f0">${patternHtml}</code> → <span class="${sub.passed ? 'val-true' : 'val-false'}">${sub.passed}</span>`;

        const detailsDiv = document.createElement('div');
        detailsDiv.className = 'condition-details';
        detailsDiv.style.cssText = 'padding-left: 1.5rem; font-size: 0.8rem; margin-top: 0.25rem;';
        detailsDiv.innerHTML = sub.details;

        const collapsible = createCollapsible(headerHtml, detailsDiv, false);
        subDiv.appendChild(collapsible);
    } else {
        subDiv.innerHTML = `<span style="color:${statusColor}">${statusIcon}</span> <code style="font-size:0.8rem;color:#e2e8f0">${patternHtml}</code> → <span class="${sub.passed ? 'val-true' : 'val-false'}">${sub.passed}</span>`;
    }

    return subDiv;
}

// Helper to escape HTML
function escapeHtml(str) {
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

// ============== Syntax Highlighting ==============
const HIGHLIGHT_KEYWORDS = new Set(['and', 'or', 'not', 'true', 'false', 'null', 'empty', 'eq', 'ne', 'lt', 'le', 'gt', 'ge', 'div', 'mod']);
const HIGHLIGHT_FUNCTIONS = new Set([
    // String functions
    'contains', 'matches', 'find', 'findGroups', 'matchesWithRegex',
    'substring', 'startsWith', 'endsWith', 'toLowerCase', 'toUpperCase',
    'trim', 'trimStart', 'trimEnd', 'replace', 'replaceAll', 'concat',
    'charAt', 'charCodeAt', 'repeat', 'padStart', 'padEnd',
    // Array functions
    'split', 'join', 'array', 'first', 'last', 'reverse', 'sort', 'slice',
    // Object functions
    'keys', 'keySet', 'values', 'entries',
    // Utility functions
    'length', 'size', 'indexOf', 'lastIndexOf', 'empty', 'isEmpty',
    'isNull', 'isNotNull', 'defaultTo', 'coalesce',
    // Type conversion
    'bool', 'boolean', 'integer', 'number', 'toString',
    // Encoding
    'encodeBase64', 'decodeBase64', 'urlEncode', 'urlDecode', 'jsonParse', 'jsonStringify',
    // Math
    'abs', 'ceil', 'floor', 'round', 'min', 'max', 'random',
    // Date/Time
    'now', 'timestamp',
    // Type checking
    'typeof', 'isString', 'isNumber', 'isBoolean', 'isArray', 'isObject',
]);

function highlightExpression(text) {
    if (!text) return '';

    let result = '';
    let i = 0;

    while (i < text.length) {
        // Check for expression delimiters ${...} or #{...}
        if ((text[i] === '$' || text[i] === '#') && text[i + 1] === '{') {
            result += `<span class="tok-delimiter">${escapeHtml(text.slice(i, i + 2))}</span>`;
            i += 2;
            continue;
        }

        // Check for closing brace
        if (text[i] === '}') {
            result += `<span class="tok-delimiter">}</span>`;
            i++;
            continue;
        }

        // Check for strings
        if (text[i] === '"' || text[i] === "'") {
            const quote = text[i];
            let str = quote;
            i++;
            while (i < text.length && text[i] !== quote) {
                if (text[i] === '\\' && i + 1 < text.length) {
                    str += text[i] + text[i + 1];
                    i += 2;
                } else {
                    str += text[i];
                    i++;
                }
            }
            if (i < text.length) {
                str += text[i];
                i++;
            }
            result += `<span class="tok-string">${escapeHtml(str)}</span>`;
            continue;
        }

        // Check for numbers
        if (/\d/.test(text[i])) {
            let num = '';
            while (i < text.length && /[\d.]/.test(text[i])) {
                num += text[i];
                i++;
            }
            result += `<span class="tok-number">${escapeHtml(num)}</span>`;
            continue;
        }

        // Check for identifiers/keywords
        if (/[a-zA-Z_]/.test(text[i])) {
            let ident = '';
            while (i < text.length && /[a-zA-Z0-9_]/.test(text[i])) {
                ident += text[i];
                i++;
            }

            // Look ahead for function call
            let j = i;
            while (j < text.length && /\s/.test(text[j])) j++;
            const isFunc = j < text.length && text[j] === '(';

            if (HIGHLIGHT_KEYWORDS.has(ident.toLowerCase())) {
                result += `<span class="tok-keyword">${escapeHtml(ident)}</span>`;
            } else if (HIGHLIGHT_FUNCTIONS.has(ident) || isFunc) {
                result += `<span class="tok-function">${escapeHtml(ident)}</span>`;
            } else {
                result += `<span class="tok-property">${escapeHtml(ident)}</span>`;
            }
            continue;
        }

        // Check for operators
        if ('!=<>'.includes(text[i])) {
            let op = text[i];
            if (i + 1 < text.length && '='.includes(text[i + 1])) {
                op += text[i + 1];
                i++;
            }
            result += `<span class="tok-operator">${escapeHtml(op)}</span>`;
            i++;
            continue;
        }

        // Brackets
        if ('()[]'.includes(text[i])) {
            result += `<span class="tok-bracket">${escapeHtml(text[i])}</span>`;
            i++;
            continue;
        }

        // Dot and comma
        if (text[i] === '.' || text[i] === ',') {
            result += `<span class="tok-delimiter">${escapeHtml(text[i])}</span>`;
            i++;
            continue;
        }

        // Whitespace and other
        result += escapeHtml(text[i]);
        i++;
    }

    return result;
}

function escapeHtml(text) {
    return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function updateHighlight() {
    const textarea = document.getElementById('condition');
    const backdrop = document.getElementById('condition-highlight');
    const text = textarea.value;
    backdrop.innerHTML = highlightExpression(text) + '\n'; // extra newline to match textarea
}

// ============== Format Expression ==============
function formatExpression(text) {
    // Extract content from ${...} or #{...}
    const match = text.match(/^(\$\{|\#\{)([\s\S]*)\}$/);
    if (!match) return text;

    const prefix = match[1];
    const inner = match[2].trim();

    // Parse into AST-like structure and format
    try {
        const formatted = formatExpr(inner, 1);
        return prefix + '\n' + formatted + '\n}';
    } catch (e) {
        // If parsing fails, return original
        return text;
    }
}

function tokenizeForFormat(expr) {
    const tokens = [];
    let i = 0;

    while (i < expr.length) {
        // Skip whitespace
        if (/\s/.test(expr[i])) {
            i++;
            continue;
        }

        // String
        if (expr[i] === '"' || expr[i] === "'") {
            const quote = expr[i];
            let str = quote;
            i++;
            while (i < expr.length && expr[i] !== quote) {
                if (expr[i] === '\\') { str += expr[i++]; }
                if (i < expr.length) { str += expr[i++]; }
            }
            if (i < expr.length) { str += expr[i++]; }
            tokens.push({ type: 'string', value: str });
            continue;
        }

        // Identifier or keyword
        if (/[a-zA-Z_]/.test(expr[i])) {
            let ident = '';
            while (i < expr.length && /[a-zA-Z0-9_]/.test(expr[i])) {
                ident += expr[i++];
            }
            const lower = ident.toLowerCase();
            if (lower === 'and' || lower === 'or' || lower === 'not') {
                tokens.push({ type: 'keyword', value: lower });
            } else {
                tokens.push({ type: 'ident', value: ident });
            }
            continue;
        }

        // Numbers
        if (/\d/.test(expr[i])) {
            let num = '';
            while (i < expr.length && /[\d.]/.test(expr[i])) {
                num += expr[i++];
            }
            tokens.push({ type: 'number', value: num });
            continue;
        }

        // Two-char operators
        if (i + 1 < expr.length) {
            const two = expr[i] + expr[i + 1];
            if (['==', '!=', '<=', '>=', '&&', '||'].includes(two)) {
                tokens.push({ type: 'op', value: two });
                i += 2;
                continue;
            }
        }

        // Single-char operators that need spacing
        if (['>', '<', '+', '-', '*', '/', '%', '?', ':'].includes(expr[i])) {
            tokens.push({ type: 'op', value: expr[i] });
            i++;
            continue;
        }

        // Single char (parens, brackets, comma, dot, etc)
        tokens.push({ type: 'char', value: expr[i] });
        i++;
    }

    return tokens;
}

function formatExpr(expr, baseIndent) {
    const tokens = tokenizeForFormat(expr);

    // If the entire expression is wrapped in parens, strip them and recurse
    if (tokens.length > 0 && tokens[0].value === '(') {
        let depth = 0;
        let closeIdx = -1;
        for (let i = 0; i < tokens.length; i++) {
            if (tokens[i].value === '(') depth++;
            else if (tokens[i].value === ')') {
                depth--;
                if (depth === 0) { closeIdx = i; break; }
            }
        }
        if (closeIdx === tokens.length - 1) {
            // Entire expression is wrapped - format inner content
            const inner = tokens.slice(1, closeIdx);
            const innerStr = tokensToString(inner);
            const innerFormatted = formatExpr(innerStr.trim(), baseIndent);
            // Check if inner was formatted with newlines
            if (innerFormatted.includes('\n')) {
                return '  '.repeat(baseIndent) + '(' + innerFormatted.trim() + ')';
            }
            // Keep it wrapped
            return '  '.repeat(baseIndent) + '(' + innerFormatted.trim() + ')';
        }
    }

    // Find top-level OR splits (these are major branches)
    const orBranches = splitByTopLevelOp(tokens, 'or');

    // Split OR if there are 2 or more branches
    if (orBranches.length > 1) {
        // Multiple OR branches - format each on its own line
        const indent = '  '.repeat(baseIndent);
        const formatted = orBranches.map((branch, i) => {
            const branchStr = formatBranch(branch, baseIndent);
            return indent + branchStr;
        });
        return formatted.join('\nor\n');
    }

    // Single branch or simple "a or b" - check for AND
    const andBranches = splitByTopLevelOp(tokens, 'and');

    if (andBranches.length > 1) {
        const indent = '  '.repeat(baseIndent);
        const formatted = andBranches.map((branch, i) => {
            const branchStr = formatBranch(branch, baseIndent);
            return branchStr;
        });
        return indent + formatted.join(' and ');
    }

    // No top-level operators, return as-is
    return '  '.repeat(baseIndent) + tokensToString(tokens);
}

function splitByTopLevelOp(tokens, op) {
    const branches = [];
    let current = [];
    let depth = 0;

    for (const tok of tokens) {
        if (tok.value === '(' || tok.value === '[') {
            depth++;
            current.push(tok);
        } else if (tok.value === ')' || tok.value === ']') {
            depth--;
            current.push(tok);
        } else if (depth === 0 && tok.type === 'keyword' && tok.value === op) {
            if (current.length > 0) {
                branches.push(current);
            }
            current = [];
        } else {
            current.push(tok);
        }
    }

    if (current.length > 0) {
        branches.push(current);
    }

    return branches;
}

function formatBranch(tokens, baseIndent) {
    // Check if this is a parenthesized group
    if (tokens.length > 0 && tokens[0].value === '(') {
        // Find matching close paren
        let depth = 0;
        let closeIdx = -1;
        for (let i = 0; i < tokens.length; i++) {
            if (tokens[i].value === '(') depth++;
            else if (tokens[i].value === ')') {
                depth--;
                if (depth === 0) { closeIdx = i; break; }
            }
        }

        if (closeIdx === tokens.length - 1) {
            // Entire branch is wrapped in parens
            const inner = tokens.slice(1, closeIdx);

            // First check if inner is double-wrapped (((...)))
            if (inner.length > 0 && inner[0].value === '(') {
                let innerDepth = 0;
                let innerClose = -1;
                for (let i = 0; i < inner.length; i++) {
                    if (inner[i].value === '(') innerDepth++;
                    else if (inner[i].value === ')') {
                        innerDepth--;
                        if (innerDepth === 0) { innerClose = i; break; }
                    }
                }
                if (innerClose === inner.length - 1) {
                    // It's ((content)) - recurse into inner with increased indent
                    const innerFormatted = formatBranch(inner, baseIndent + 1);
                    if (innerFormatted.includes('\n')) {
                        return '(\n  ' + '  '.repeat(baseIndent) + innerFormatted + '\n' + '  '.repeat(baseIndent) + ')';
                    }
                }
            }

            // Check for AND + OR pattern: (A and B or C or D...) or (A and (B or C or D...))
            // Find the first top-level 'and'
            const innerAnds = splitByTopLevelOp(inner, 'and');
            if (innerAnds.length >= 2) {
                // Combine everything after first 'and' and check for 'or' chain
                const afterAnd = [];
                for (let i = 1; i < innerAnds.length; i++) {
                    if (i > 1) afterAnd.push({ type: 'keyword', value: 'and' });
                    afterAnd.push(...innerAnds[i]);
                }

                // Check if afterAnd is a parenthesized OR chain: (B or C or D...)
                if (afterAnd.length > 0 && afterAnd[0].value === '(') {
                    let parenDepth = 0;
                    let parenClose = -1;
                    for (let i = 0; i < afterAnd.length; i++) {
                        if (afterAnd[i].value === '(') parenDepth++;
                        else if (afterAnd[i].value === ')') {
                            parenDepth--;
                            if (parenDepth === 0) { parenClose = i; break; }
                        }
                    }
                    if (parenClose === afterAnd.length - 1) {
                        // afterAnd is entirely wrapped in parens
                        const insideParen = afterAnd.slice(1, parenClose);
                        const orParts = splitByTopLevelOp(insideParen, 'or');
                        if (orParts.length > 1) {
                            // Pattern: (condition and (or_item1 or or_item2 or ...))
                            const condPart = tokensToString(innerAnds[0]);
                            const indent = '  '.repeat(baseIndent + 1);
                            const innerIndent = '  '.repeat(baseIndent + 2);
                            const lines = orParts.map(branch => innerIndent + tokensToString(branch));
                            return '(' + condPart + ' and (\n' + lines.join(' or\n') + '\n' + indent + '))';
                        }
                    }
                }

                const orParts = splitByTopLevelOp(afterAnd, 'or');
                if (orParts.length > 1) {
                    // Pattern: (condition and first_or_item or second_or_item or ...)
                    const condPart = tokensToString(innerAnds[0]);
                    const indent = '  '.repeat(baseIndent + 1);
                    const innerIndent = '  '.repeat(baseIndent + 2);
                    const lines = orParts.map(branch => innerIndent + tokensToString(branch));
                    return '(' + condPart + ' and (\n' + lines.join(' or\n') + '\n' + indent + '))';
                }
            }

            // Check if inner has OR chains (the common case for long lists)
            const innerOrs = splitByTopLevelOp(inner, 'or');
            if (innerOrs.length > 1) {
                // Many OR branches inside - format as block
                const indent = '  '.repeat(baseIndent + 1);
                const lines = innerOrs.map(branch => indent + tokensToString(branch));
                return '(\n' + lines.join(' or\n') + '\n' + '  '.repeat(baseIndent) + ')';
            }
        }
    }

    return tokensToString(tokens);
}

function tokensToString(tokens) {
    let result = '';
    let prevTok = null;

    for (const tok of tokens) {
        // Determine if we need a space before this token
        let needSpace = false;

        if (prevTok) {
            // Space before keywords (and, or, not) unless after (
            if (tok.type === 'keyword') {
                needSpace = prevTok.value !== '(';
            }
            // Space after keywords unless before )
            else if (prevTok.type === 'keyword') {
                needSpace = tok.value !== ')';
            }
            // Space between identifiers/numbers/strings
            else if ((prevTok.type === 'ident' || prevTok.type === 'number' || prevTok.type === 'string') &&
                     (tok.type === 'ident' || tok.type === 'number' || tok.type === 'string')) {
                needSpace = true;
            }
            // Space after ) if followed by ( or ident
            else if (prevTok.value === ')' && (tok.value === '(' || tok.type === 'ident')) {
                needSpace = true;
            }
            // Space around operators like ==, !=, etc
            else if (tok.type === 'op') {
                needSpace = prevTok.value !== '(';
            }
            else if (prevTok.type === 'op') {
                needSpace = tok.value !== ')';
            }
        }

        if (needSpace && result.length > 0 && !result.endsWith(' ')) {
            result += ' ';
        }

        result += tok.value;
        prevTok = tok;
    }

    return result.trim();
}

// ============== Editor Event Bindings ==============
const conditionTextarea = document.getElementById('condition');
const conditionHighlight = document.getElementById('condition-highlight');

conditionTextarea.addEventListener('input', updateHighlight);
conditionTextarea.addEventListener('scroll', () => {
    conditionHighlight.scrollTop = conditionTextarea.scrollTop;
    conditionHighlight.scrollLeft = conditionTextarea.scrollLeft;
});

document.getElementById('format-btn').addEventListener('click', () => {
    const textarea = document.getElementById('condition');
    const text = textarea.value.trim();
    if (text) {
        const formatted = formatExpression(text);
        textarea.value = formatted;
        // Force sync scroll position
        const backdrop = document.getElementById('condition-highlight');
        backdrop.scrollTop = 0;
        textarea.scrollTop = 0;
        updateHighlight();
    }
});

// Initial highlight
updateHighlight();
</script>
</body>
</html>
