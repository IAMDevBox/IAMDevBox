<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IG Condition Validator</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            min-height: 100vh;
            padding: 1rem;
        }
        .container { width: 100%; overflow-x: hidden; }
        h1 { text-align: center; margin-bottom: 0.25rem; color: #f8fafc; font-size: 1.5rem; }
        .subtitle { text-align: center; color: #94a3b8; margin-bottom: 1rem; font-size: 0.85rem; }
        .grid { display: grid; grid-template-columns: 1fr 6px 1fr; min-width: 0; align-items: start; }
        .grid > .panel { min-width: 0; }
        .grid > .panel-left { padding-right: 0.5rem; }
        .grid > .panel-right { padding-left: 0.5rem; }
        .resizer {
            background: #334155;
            cursor: col-resize;
            border-radius: 3px;
            transition: background 0.2s;
            align-self: stretch;
        }
        .resizer:hover, .resizer.dragging { background: #3b82f6; }
        @media (max-width: 900px) {
            .grid { grid-template-columns: 1fr; }
            .resizer { display: none; }
            .grid > .panel-left, .grid > .panel-right { padding: 0; }
        }
        .card {
            background: #1e293b;
            border-radius: 8px;
            padding: 0.75rem;
            border: 1px solid #334155;
            min-width: 0;
            overflow: hidden;
        }
        /* Add margin to diagnosis result only when preview card is visible */
        #request-preview-card:not([style*="display: none"]) + #diagnosis-result-card {
            margin-top: 0.5rem;
        }
        .card-title { font-size: 0.95rem; font-weight: 600; margin-bottom: 0.5rem; color: #f1f5f9; }
        .form-group { margin-bottom: 0.5rem; }
        label { display: block; font-size: 0.8rem; color: #94a3b8; margin-bottom: 0.25rem; }
        input, textarea, select {
            width: 100%;
            padding: 0.5rem;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 6px;
            color: #e2e8f0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85rem;
        }
        input:focus, textarea:focus { outline: none; border-color: #3b82f6; }
        textarea { resize: vertical; min-height: 100px; }
        .condition-input { min-height: 100px; font-size: 0.9rem; }
        .inline-group { display: grid; grid-template-columns: 100px 1fr; gap: 0.5rem; }
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
        }
        .btn-primary { background: #3b82f6; color: white; }
        .btn-primary:hover { background: #2563eb; }
        .result-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem;
            border-radius: 6px;
            margin-bottom: 0.5rem;
        }
        .result-passed { background: #064e3b; border: 1px solid #10b981; }
        .result-failed { background: #450a0a; border: 1px solid #ef4444; }
        .result-error { background: #451a03; border: 1px solid #f59e0b; }
        .result-icon { font-size: 1.2rem; }
        .condition-list { display: flex; flex-direction: column; gap: 0.4rem; }
        .condition-item {
            padding: 0.5rem;
            background: #0f172a;
            border-radius: 6px;
            border-left: 3px solid #334155;
        }
        .condition-item.passed { border-left-color: #10b981; }
        .condition-item.failed { border-left-color: #ef4444; }
        .condition-expr { font-family: 'Monaco', 'Menlo', monospace; font-size: 0.8rem; color: #f8fafc; margin-bottom: 0.25rem; }
        .condition-details { font-size: 0.75rem; color: #94a3b8; font-family: 'Monaco', 'Menlo', monospace; word-break: break-all; }
        .condition-details .fn-name { color: #dcdcaa; font-weight: 600; }
        .condition-details .fn-arg { color: #ce9178; }
        .condition-details .fn-result { color: #4ec9b0; }
        .condition-details .val-true { color: #4ec9b0; }
        .condition-details .val-false { color: #f14c4c; }
        .condition-details .op { color: #c586c0; font-weight: 600; }
        .condition-details .match-highlight { background: #365314; color: #a3e635; padding: 0 2px; border-radius: 2px; }
        /* Pattern highlighting for condition display */
        .fn-name { color: #dcdcaa; font-weight: 600; }
        .pattern-highlight { color: #ce9178; background: rgba(206, 145, 120, 0.15); padding: 0 2px; border-radius: 2px; }
        .val-true { color: #4ec9b0; font-weight: 600; }
        .val-false { color: #f14c4c; font-weight: 600; }
        .condition-suggestion { font-size: 0.75rem; color: #fbbf24; margin-top: 0.25rem; }
        .collapsible { cursor: pointer; user-select: none; }
        .collapsible:hover { opacity: 0.8; }
        .collapsible::before { content: '▶'; display: inline-block; margin-right: 0.35rem; font-size: 0.6rem; transition: transform 0.2s; color: #64748b; }
        .collapsible.expanded::before { transform: rotate(90deg); }
        .collapse-content { display: none; margin-top: 0.25rem; }
        .collapse-content.show { display: block; }
        .status-icon { margin-right: 0.35rem; }
        .hidden { display: none; }
        .btn-icon {
            padding: 0.35rem 0.5rem;
            background: #334155;
            border: none;
            border-radius: 4px;
            color: #94a3b8;
            cursor: pointer;
        }
        .btn-icon:hover { background: #475569; color: #e2e8f0; }
        .add-btn {
            margin-top: 0.35rem;
            background: transparent;
            border: 1px dashed #475569;
            color: #94a3b8;
            padding: 0.35rem;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        .add-btn:hover { border-color: #3b82f6; color: #3b82f6; }

        /* Preview panels */
        .preview-content {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.75rem;
            max-height: 250px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        .preview-row {
            display: grid;
            grid-template-columns: minmax(80px, 110px) minmax(200px, 280px) 1fr;
            gap: 0.5rem;
            padding: 0.35rem 0;
            border-bottom: 1px solid #334155;
            align-items: baseline;
            min-width: 0;
        }
        .preview-row:last-child { border-bottom: none; }
        .preview-field { color: #94a3b8; font-size: 0.85rem; word-break: break-word; }
        .preview-var { color: #4ec9b0; font-size: 0.8rem; word-break: break-all; }
        .preview-value {
            color: #e2e8f0;
            word-break: break-all;
        }
        .preview-value.empty { color: #64748b; font-style: italic; }
        .toggle-btn {
            font-size: 0.75rem;
            color: #64748b;
            cursor: pointer;
            margin-left: 0.5rem;
        }
        .toggle-btn:hover { color: #94a3b8; }
        .preview-content.collapsed { display: none; }
        .header-item {
            background: #0f172a;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            margin: 0.15rem 0;
            font-size: 0.8rem;
        }
        .header-name { color: #dcdcaa; }
        .header-sep { color: #64748b; }
        .header-value { color: #ce9178; }

        /* History dropdown */
        .history-container { display: inline-block; margin-left: 0.5rem; }
        .history-btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            background: #334155;
            border: none;
            border-radius: 4px;
            color: #94a3b8;
            cursor: pointer;
        }
        .history-btn:hover { background: #475569; color: #e2e8f0; }
        .history-dropdown {
            display: none;
            position: fixed;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 6px;
            min-width: 350px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .history-dropdown.show { display: block; }
        .history-item {
            padding: 0.5rem;
            border-bottom: 1px solid #334155;
            cursor: pointer;
            position: relative;
        }
        .history-item:hover { background: #334155; }
        .history-item:last-child { border-bottom: none; }
        .history-delete {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: #64748b;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
            line-height: 1;
            border-radius: 4px;
        }
        .history-delete:hover { color: #ef4444; background: rgba(239, 68, 68, 0.1); }
        .history-time { font-size: 0.7rem; color: #64748b; }
        .history-condition { font-size: 0.8rem; color: #e2e8f0; margin-top: 0.25rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .history-request { font-size: 0.7rem; color: #94a3b8; margin-top: 0.15rem; }
        .history-empty { padding: 0.5rem; text-align: center; color: #64748b; }
        .history-clear { padding: 0.5rem; text-align: center; border-top: 1px solid #334155; }
        .history-clear-btn { font-size: 0.75rem; color: #ef4444; background: none; border: none; cursor: pointer; }
        .history-clear-btn:hover { text-decoration: underline; }

        /* Syntax highlighting editor */
        .editor-container {
            position: relative;
            min-height: 180px;
            display: flex;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 6px;
            overflow: hidden;
        }
        .editor-container:focus-within { border-color: #3b82f6; }
        .line-numbers {
            padding: 0.5rem 0;
            padding-right: 0.35rem;
            padding-left: 0.35rem;
            background: #0f172a;
            border-right: 1px solid #334155;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            color: #64748b;
            text-align: right;
            user-select: none;
            border-radius: 6px 0 0 6px;
            min-width: 2rem;
            flex-shrink: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }
        /* Hide scrollbar for line numbers but keep scrolling */
        .line-numbers::-webkit-scrollbar { display: none; }
        .line-numbers { -ms-overflow-style: none; scrollbar-width: none; }
        .editor-wrapper {
            position: relative;
            flex: 1;
            min-width: 0;
        }
        .editor-backdrop {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            padding: 0.5rem;
            background: transparent;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            white-space: pre;
            overflow-y: auto;
            overflow-x: auto;
            pointer-events: none;
        }
        .editor-textarea {
            position: relative;
            width: 100%;
            height: 180px;
            padding: 0.5rem;
            background: transparent;
            border: none;
            border-radius: 0 6px 6px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            color: transparent;
            caret-color: #e2e8f0;
            resize: vertical;
            z-index: 1;
            overflow-y: auto;
            overflow-x: auto;
            white-space: pre;
        }
        .editor-textarea:focus { outline: none; }
        .editor-textarea::placeholder { color: #64748b; }

        /* Token colors */
        .tok-keyword { color: #c084fc; font-weight: 500; }
        .tok-string { color: #86efac; }
        .tok-number { color: #fcd34d; }
        .tok-operator { color: #60a5fa; }
        .tok-function { color: #38bdf8; }
        .tok-property { color: #f8fafc; }
        .tok-bracket { color: #f472b6; }
        .tok-delimiter { color: #94a3b8; }
        .tok-error { color: #f87171; text-decoration: wavy underline #ef4444; }

        /* Syntax error display */
        .syntax-error {
            display: none;
            margin-top: 0.35rem;
            padding: 0.35rem 0.5rem;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            border-radius: 4px;
            font-size: 0.75rem;
            color: #fca5a5;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        .syntax-error.show { display: block; }
        .syntax-error-icon { margin-right: 0.35rem; }
        .syntax-error-pos { color: #94a3b8; margin-left: 0.35rem; font-size: 0.7rem; }
        .syntax-error-goto { margin-left: 0.5rem; color: #60a5fa; cursor: pointer; text-decoration: underline; user-select: none; }
        .syntax-error-goto:hover { color: #93c5fd; }
        .error-highlight { background: rgba(239, 68, 68, 0.3); border-radius: 2px; }
        .warning-highlight { background: rgba(245, 158, 11, 0.3); border-radius: 2px; }
        .line-numbers .error-line { color: #ef4444; font-weight: bold; }
        .line-numbers .warning-line { color: #f59e0b; font-weight: bold; }

        /* Format button */
        .editor-toolbar {
            display: flex;
            justify-content: flex-end;
            gap: 0.35rem;
            margin-bottom: 0.35rem;
        }
        .btn-small {
            padding: 0.2rem 0.5rem;
            font-size: 0.75rem;
            background: #334155;
            border: none;
            border-radius: 4px;
            color: #94a3b8;
            cursor: pointer;
        }
        .btn-small:hover { background: #475569; color: #e2e8f0; }

        /* Regex tester */
        .regex-result {
            margin-top: 0.5rem;
            padding: 0.5rem;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.8rem;
            display: none;
        }
        .regex-result.show { display: block; }
        .regex-result.match { background: rgba(16, 185, 129, 0.15); border: 1px solid #10b981; color: #6ee7b7; }
        .regex-result.no-match { background: rgba(239, 68, 68, 0.15); border: 1px solid #ef4444; color: #fca5a5; }
        .regex-result.error { background: rgba(245, 158, 11, 0.15); border: 1px solid #f59e0b; color: #fcd34d; }
        .regex-match-highlight { background: #365314; color: #a3e635; padding: 0 2px; border-radius: 2px; }
        .regex-groups { margin-top: 0.35rem; padding-top: 0.35rem; border-top: 1px solid rgba(255,255,255,0.1); }
        .regex-group-item { margin: 0.15rem 0; }
        .regex-group-name { color: #94a3b8; }
        .regex-group-value { color: #86efac; }


        /* Performance tips */
        .performance-tips {
            font-size: 0.75rem;
            background: #0f172a;
            border-radius: 4px;
            padding: 0.5rem;
        }
        .performance-tip {
            padding: 0.35rem 0;
            border-bottom: 1px solid #1e293b;
            word-break: break-word;
        }
        .performance-tip:last-child { border-bottom: none; }
        .performance-tip.warning { color: #fcd34d; }
        .performance-tip.info { color: #94a3b8; }
        .tip-icon { margin-right: 0.35rem; }
        .tip-type { color: #64748b; margin-right: 0.35rem; font-size: 0.7rem; }

        /* Regex samples */
        .regex-samples {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
        }
        .regex-sample {
            padding: 0.15rem 0.4rem;
            font-size: 0.65rem;
            background: #334155;
            border: none;
            border-radius: 3px;
            color: #94a3b8;
            cursor: pointer;
        }
        .regex-sample:hover { background: #475569; color: #e2e8f0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>IG Condition Validator</h1>
        <p class="subtitle">Debug ForgeRock Identity Gateway condition expressions (Static Version)</p>

        <div class="grid" id="main-grid">
            <div class="panel panel-left">
                <div class="card">
                    <h3 class="card-title">Request</h3>

                    <div class="form-group">
                        <label>Paste cURL command or URL</label>
                        <textarea id="curl-input" placeholder='curl -X GET "https://api.example.com/users?status=active" -H "Authorization: Bearer token"

Or just paste a URL:
https://api.example.com/path%2Fencoded?query=value%26other'></textarea>
                    </div>
                </div>

                <div class="card" style="margin-top: 0.75rem;">
                    <h3 class="card-title" style="display: flex; align-items: center; justify-content: space-between;">
                        <span>Condition Expression
                            <div class="history-container">
                                <button class="history-btn" id="history-btn">History ▾</button>
                                <div class="history-dropdown" id="history-dropdown">
                                    <!-- Filled by JS -->
                                </div>
                            </div>
                        </span>
                        <button class="btn-small" id="format-btn" title="Format expression">Format</button>
                    </h3>
                    <div class="form-group">
                        <div class="editor-container">
                            <div class="line-numbers" id="line-numbers">1</div>
                            <div class="editor-wrapper">
                                <textarea id="condition" class="editor-textarea" placeholder='${request.method == "GET" and contains(request.uri.path, "/api/")}'></textarea>
                                <div id="condition-highlight" class="editor-backdrop"></div>
                            </div>
                        </div>
                        <div id="syntax-error" class="syntax-error"></div>
                    </div>
                    <div style="text-align: center;"><button class="btn btn-primary" id="diagnose-btn">Diagnose</button></div>
                </div>

                <div class="card" style="margin-top: 0.5rem;">
                    <h3 class="card-title" style="display: flex; justify-content: space-between; align-items: center;">
                        <span>Regex Tester <span class="toggle-btn" id="regex-tester-toggle">▼</span></span>
                        <span class="regex-samples" id="regex-samples">
                            <button class="regex-sample" data-pattern="^/api/v[0-9]+/.*" data-test="/api/v2/users/123">API Path</button>
                            <button class="regex-sample" data-pattern="^/(admin|internal)/.*" data-test="/admin/settings">Protected</button>
                            <button class="regex-sample" data-pattern="^/public/.*|^/health$|^/ready$" data-test="/health">Whitelist</button>
                            <button class="regex-sample" data-pattern="Bearer [A-Za-z0-9-_.]+" data-test="Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0">JWT</button>
                            <button class="regex-sample" data-pattern="^Basic [A-Za-z0-9+/=]+$" data-test="Basic dXNlcjpwYXNz">Basic</button>
                            <button class="regex-sample" data-pattern="^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$" data-test="550e8400-e29b-41d4-a716-446655440000">UUID</button>
                            <button class="regex-sample" data-pattern="^(application/json|text/plain)(;.*)?$" data-test="application/json; charset=utf-8">Content-Type</button>
                            <button class="regex-sample" data-pattern="^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$" data-test="192.168.1.100">IP</button>
                        </span>
                    </h3>
                    <div id="regex-tester-content">
                        <div class="form-group">
                            <label>Pattern (Java regex)</label>
                            <input type="text" id="regex-pattern" placeholder="e.g., ^/api/v[0-9]+/users.*">
                        </div>
                        <div class="form-group">
                            <label>Test String</label>
                            <input type="text" id="regex-test-string" placeholder="e.g., /api/v2/users/123">
                        </div>
                        <div class="form-group" style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-primary" id="regex-test-btn" style="flex: 1;">Test matches()</button>
                            <button class="btn btn-primary" id="regex-find-btn" style="flex: 1;">Test find()</button>
                        </div>
                        <div id="regex-result" class="regex-result"></div>
                    </div>
                </div>
            </div>

            <div class="resizer" id="grid-resizer"></div>

            <div class="panel panel-right">
                <div class="card" id="request-preview-card" style="display: none;">
                    <h3 class="card-title">Request &amp; Variables <span id="preview-toggle" class="toggle-btn">▼</span></h3>
                    <div id="request-preview" class="preview-content">
                        <!-- Filled by JS -->
                    </div>
                </div>

                <div class="card" id="diagnosis-result-card">
                    <h3 class="card-title">Diagnosis Result</h3>
                    <div id="result-container">
                        <p style="color: #64748b; text-align: center; padding: 1rem;">
                            Enter a condition and click "Diagnose" to see results
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
// ============== Lexer ==============
const TokenType = {
    STRING: 'STRING', NUMBER: 'NUMBER', BOOLEAN: 'BOOLEAN', NULL: 'NULL',
    IDENTIFIER: 'IDENTIFIER', EQ: 'EQ', NE: 'NE', LT: 'LT', LE: 'LE', GT: 'GT', GE: 'GE',
    AND: 'AND', OR: 'OR', NOT: 'NOT', PLUS: 'PLUS', MINUS: 'MINUS',
    MULTIPLY: 'MULTIPLY', DIVIDE: 'DIVIDE', MODULO: 'MODULO', EMPTY: 'EMPTY',
    TERNARY_IF: 'TERNARY_IF', TERNARY_ELSE: 'TERNARY_ELSE',
    DOT: 'DOT', COMMA: 'COMMA', LPAREN: 'LPAREN', RPAREN: 'RPAREN',
    LBRACKET: 'LBRACKET', RBRACKET: 'RBRACKET',
    EXPR_START: 'EXPR_START', EXPR_END: 'EXPR_END', EOF: 'EOF', ERROR: 'ERROR'
};

const KEYWORDS = {
    'true': TokenType.BOOLEAN, 'false': TokenType.BOOLEAN, 'null': TokenType.NULL,
    'and': TokenType.AND, 'or': TokenType.OR, 'not': TokenType.NOT,
    'div': TokenType.DIVIDE, 'mod': TokenType.MODULO, 'empty': TokenType.EMPTY,
    'eq': TokenType.EQ, 'ne': TokenType.NE, 'lt': TokenType.LT,
    'le': TokenType.LE, 'gt': TokenType.GT, 'ge': TokenType.GE,
};

class Lexer {
    constructor(source) {
        this.source = source;
        this.pos = 0;
        this.line = 1;
        this.column = 1;
    }

    get current() { return this.pos < this.source.length ? this.source[this.pos] : null; }
    peek(offset = 1) { return this.pos + offset < this.source.length ? this.source[this.pos + offset] : null; }

    advance() {
        const char = this.current;
        this.pos++;
        if (char === '\n') { this.line++; this.column = 1; } else { this.column++; }
        return char;
    }

    skipWhitespace() { while (this.current && /\s/.test(this.current)) this.advance(); }

    readString(quote) {
        const line = this.line, column = this.column;
        this.advance();
        let result = '';
        while (this.current && this.current !== quote) {
            // Handle escape sequences
            if (this.current === '\\') {
                this.advance();
                const c = this.current;
                if (c === 'n') result += '\n';
                else if (c === 't') result += '\t';
                else if (c === '\\') result += '\\';
                else if (c === quote) result += quote;
                else result += c || '';
                this.advance();
            }
            // Handle URL-encoded quotes: %27 (') and %22 (")
            // These should be kept as-is in the string, not treated as string terminators
            else if (this.current === '%') {
                const next2 = (this.peek(1) || '') + (this.peek(2) || '');
                if (next2.toLowerCase() === '27' || next2.toLowerCase() === '22') {
                    // Include %27 or %22 as literal characters in the string
                    result += this.current; // %
                    this.advance();
                    result += this.current; // 2
                    this.advance();
                    result += this.current; // 7 or 2
                    this.advance();
                } else {
                    result += this.current;
                    this.advance();
                }
            }
            else {
                result += this.current;
                this.advance();
            }
        }
        if (this.current !== quote) throw new Error(`Unterminated string at ${line}:${column}`);
        this.advance();
        return { type: TokenType.STRING, value: result, line, column };
    }

    readNumber() {
        const line = this.line, column = this.column;
        let result = '';
        while (this.current && /\d/.test(this.current)) { result += this.current; this.advance(); }
        if (this.current === '.' && this.peek() && /\d/.test(this.peek())) {
            result += this.current; this.advance();
            while (this.current && /\d/.test(this.current)) { result += this.current; this.advance(); }
        }
        return { type: TokenType.NUMBER, value: result, line, column };
    }

    readIdentifier() {
        const line = this.line, column = this.column;
        let result = '';
        while (this.current && /[\w]/.test(this.current)) { result += this.current; this.advance(); }
        const lower = result.toLowerCase();
        const type = KEYWORDS[lower] || TokenType.IDENTIFIER;
        return { type, value: type === TokenType.IDENTIFIER ? result : lower, line, column };
    }

    tokenize() {
        const tokens = [];
        while (this.current) {
            const line = this.line, column = this.column;
            if (/\s/.test(this.current)) { this.skipWhitespace(); continue; }
            if ((this.current === '$' || this.current === '#') && this.peek() === '{') {
                const start = this.current; this.advance(); this.advance();
                tokens.push({ type: TokenType.EXPR_START, value: start + '{', line, column });
                continue;
            }
            if (this.current === '}') { this.advance(); tokens.push({ type: TokenType.EXPR_END, value: '}', line, column }); continue; }
            if (this.current === '"' || this.current === "'") { tokens.push(this.readString(this.current)); continue; }
            if (/\d/.test(this.current)) { tokens.push(this.readNumber()); continue; }
            if (/[a-zA-Z_]/.test(this.current)) { tokens.push(this.readIdentifier()); continue; }

            const two = this.current + (this.peek() || '');
            if (two === '==') { this.advance(); this.advance(); tokens.push({ type: TokenType.EQ, value: '==', line, column }); continue; }
            if (two === '!=') { this.advance(); this.advance(); tokens.push({ type: TokenType.NE, value: '!=', line, column }); continue; }
            if (two === '<=') { this.advance(); this.advance(); tokens.push({ type: TokenType.LE, value: '<=', line, column }); continue; }
            if (two === '>=') { this.advance(); this.advance(); tokens.push({ type: TokenType.GE, value: '>=', line, column }); continue; }
            if (two === '&&') { this.advance(); this.advance(); tokens.push({ type: TokenType.AND, value: '&&', line, column }); continue; }
            if (two === '||') { this.advance(); this.advance(); tokens.push({ type: TokenType.OR, value: '||', line, column }); continue; }

            const ops = { '<': TokenType.LT, '>': TokenType.GT, '+': TokenType.PLUS, '-': TokenType.MINUS,
                '*': TokenType.MULTIPLY, '/': TokenType.DIVIDE, '%': TokenType.MODULO, '!': TokenType.NOT,
                '?': TokenType.TERNARY_IF, ':': TokenType.TERNARY_ELSE, '.': TokenType.DOT, ',': TokenType.COMMA,
                '(': TokenType.LPAREN, ')': TokenType.RPAREN, '[': TokenType.LBRACKET, ']': TokenType.RBRACKET };
            if (ops[this.current]) {
                const c = this.current; this.advance();
                tokens.push({ type: ops[c], value: c, line, column });
                continue;
            }
            this.advance();
            tokens.push({ type: TokenType.ERROR, value: this.source[this.pos - 1], line, column });
        }
        tokens.push({ type: TokenType.EOF, value: '', line: this.line, column: this.column });
        return tokens;
    }
}

// ============== Parser ==============
class Parser {
    constructor(source) {
        this.tokens = new Lexer(source).tokenize();
        this.pos = 0;
    }

    get current() { return this.tokens[Math.min(this.pos, this.tokens.length - 1)]; }
    advance() { const t = this.current; if (this.pos < this.tokens.length - 1) this.pos++; return t; }
    match(...types) { return types.includes(this.current.type); }
    expect(type, msg) {
        if (this.current.type === type) return this.advance();
        const t = this.current;
        // Provide more context for common errors
        if (t.type === TokenType.STRING || t.type === TokenType.NUMBER || t.type === TokenType.IDENTIFIER) {
            throw new Error(`Unexpected '${t.value}' - missing operator before it? At ${t.line}:${t.column}`);
        }
        throw new Error(`${msg}, got '${t.value}' at ${t.line}:${t.column}`);
    }

    parse() {
        if (!this.match(TokenType.EXPR_START)) throw new Error("Expression must start with '${' or '#{'");
        const start = this.advance();
        const body = this.parseTernary();
        this.expect(TokenType.EXPR_END, "Expected '}'");

        // Check for extra content after the closing }
        if (!this.match(TokenType.EOF)) {
            const t = this.current;
            throw new Error(`Unexpected content after '}': '${t.value}' at ${t.line}:${t.column}`);
        }

        return { type: 'Expression', body, deferred: start.value.startsWith('#') };
    }

    parseTernary() {
        let cond = this.parseOr();
        if (this.match(TokenType.TERNARY_IF)) {
            this.advance();
            const thenExpr = this.parseTernary();
            this.expect(TokenType.TERNARY_ELSE, "Expected ':' in ternary");
            const elseExpr = this.parseTernary();
            return { type: 'TernaryOp', condition: cond, thenExpr, elseExpr };
        }
        return cond;
    }

    parseOr() {
        let left = this.parseAnd();
        while (this.match(TokenType.OR)) { this.advance(); left = { type: 'BinaryOp', operator: 'or', left, right: this.parseAnd() }; }
        return left;
    }

    parseAnd() {
        let left = this.parseEquality();
        while (this.match(TokenType.AND)) { this.advance(); left = { type: 'BinaryOp', operator: 'and', left, right: this.parseEquality() }; }
        return left;
    }

    parseEquality() {
        let left = this.parseComparison();
        while (this.match(TokenType.EQ, TokenType.NE)) {
            const op = this.advance();
            left = { type: 'BinaryOp', operator: op.type === TokenType.EQ ? '==' : '!=', left, right: this.parseComparison() };
        }
        return left;
    }

    parseComparison() {
        let left = this.parseAdditive();
        while (this.match(TokenType.LT, TokenType.GT, TokenType.LE, TokenType.GE)) {
            const op = this.advance();
            const opMap = { [TokenType.LT]: '<', [TokenType.GT]: '>', [TokenType.LE]: '<=', [TokenType.GE]: '>=' };
            left = { type: 'BinaryOp', operator: opMap[op.type], left, right: this.parseAdditive() };
        }
        return left;
    }

    parseAdditive() {
        let left = this.parseMultiplicative();
        while (this.match(TokenType.PLUS, TokenType.MINUS)) {
            const op = this.advance();
            left = { type: 'BinaryOp', operator: op.type === TokenType.PLUS ? '+' : '-', left, right: this.parseMultiplicative() };
        }
        return left;
    }

    parseMultiplicative() {
        let left = this.parseUnary();
        while (this.match(TokenType.MULTIPLY, TokenType.DIVIDE, TokenType.MODULO)) {
            const op = this.advance();
            const opMap = { [TokenType.MULTIPLY]: '*', [TokenType.DIVIDE]: '/', [TokenType.MODULO]: '%' };
            left = { type: 'BinaryOp', operator: opMap[op.type], left, right: this.parseUnary() };
        }
        return left;
    }

    parseUnary() {
        if (this.match(TokenType.NOT, TokenType.MINUS, TokenType.EMPTY)) {
            const op = this.advance();
            const opMap = { [TokenType.NOT]: 'not', [TokenType.MINUS]: '-', [TokenType.EMPTY]: 'empty' };
            return { type: 'UnaryOp', operator: opMap[op.type], operand: this.parseUnary() };
        }
        return this.parsePostfix();
    }

    parsePostfix() {
        let node = this.parsePrimary();
        while (true) {
            if (this.match(TokenType.DOT)) {
                this.advance();
                const prop = this.expect(TokenType.IDENTIFIER, "Expected property name");
                // Check if this is a method call: obj.method()
                if (this.match(TokenType.LPAREN)) {
                    this.advance();
                    const args = [];
                    if (!this.match(TokenType.RPAREN)) {
                        args.push(this.parseTernary());
                        while (this.match(TokenType.COMMA)) { this.advance(); args.push(this.parseTernary()); }
                    }
                    this.expect(TokenType.RPAREN, "Expected ')'");
                    node = { type: 'MethodCall', object: node, method: prop.value, arguments: args };
                } else {
                    node = { type: 'PropertyAccess', object: node, property: prop.value };
                }
            } else if (this.match(TokenType.LBRACKET)) {
                this.advance();
                const index = this.parseTernary();
                this.expect(TokenType.RBRACKET, "Expected ']'");
                node = { type: 'IndexAccess', object: node, index };
            } else if (this.match(TokenType.LPAREN)) {
                if (node.type !== 'Identifier') throw new Error("Cannot call non-identifier");
                this.advance();
                const args = [];
                if (!this.match(TokenType.RPAREN)) {
                    args.push(this.parseTernary());
                    while (this.match(TokenType.COMMA)) { this.advance(); args.push(this.parseTernary()); }
                }
                this.expect(TokenType.RPAREN, "Expected ')'");
                node = { type: 'FunctionCall', name: node.name, arguments: args };
            } else break;
        }
        return node;
    }

    parsePrimary() {
        const t = this.current;
        if (this.match(TokenType.STRING)) { this.advance(); return { type: 'Literal', value: t.value, litType: 'string' }; }
        if (this.match(TokenType.NUMBER)) { this.advance(); return { type: 'Literal', value: t.value.includes('.') ? parseFloat(t.value) : parseInt(t.value), litType: 'number' }; }
        if (this.match(TokenType.BOOLEAN)) { this.advance(); return { type: 'Literal', value: t.value === 'true', litType: 'boolean' }; }
        if (this.match(TokenType.NULL)) { this.advance(); return { type: 'Literal', value: null, litType: 'null' }; }
        if (this.match(TokenType.IDENTIFIER)) { this.advance(); return { type: 'Identifier', name: t.value }; }
        if (this.match(TokenType.LPAREN)) { this.advance(); const expr = this.parseTernary(); this.expect(TokenType.RPAREN, "Expected ')'"); return expr; }
        throw new Error(`Unexpected token '${t.value}' at ${t.line}:${t.column}`);
    }
}

// ============== Built-in Functions ==============
const FUNCTIONS = {
    // String matching
    contains: (obj, val) => {
        if (obj == null) return false;
        if (typeof obj === 'string') return obj.includes(String(val));
        if (Array.isArray(obj)) return obj.includes(val);
        if (typeof obj === 'object') return val in obj;
        return false;
    },
    // find() - partial match (like Java's Matcher.find())
    find: (str, pattern) => { if (str == null) return false; try { return new RegExp(pattern).test(str); } catch { return false; } },
    // findGroups/matchingGroups - returns array [fullMatch, group1, group2, ...] or null
    findGroups: (str, pattern) => {
        if (str == null) return null;
        try { const m = str.match(new RegExp(pattern)); return m ? [m[0], ...(m.slice(1))] : null; } catch { return null; }
    },
    matchingGroups: (str, pattern) => {
        // Alias for findGroups (official IG function name)
        if (str == null) return null;
        try { const m = str.match(new RegExp(pattern)); return m ? [m[0], ...(m.slice(1))] : null; } catch { return null; }
    },
    // matches() - partial match, returns true if string CONTAINS a match for the pattern
    matches: (str, pattern) => { if (str == null) return false; try { return new RegExp(pattern).test(str); } catch { return false; } },

    // String manipulation
    substring: (str, start, end) => {
        if (str == null) return '';
        str = String(str);
        if (end === undefined) return str.substring(start);
        return str.substring(start, end);
    },
    startsWith: (str, prefix) => str == null ? false : String(str).startsWith(String(prefix)),
    endsWith: (str, suffix) => str == null ? false : String(str).endsWith(String(suffix)),
    toLowerCase: (str) => str == null ? '' : String(str).toLowerCase(),
    toUpperCase: (str) => str == null ? '' : String(str).toUpperCase(),
    trim: (str) => str == null ? '' : String(str).trim(),
    trimStart: (str) => str == null ? '' : String(str).trimStart(),
    trimEnd: (str) => str == null ? '' : String(str).trimEnd(),
    replace: (str, search, replacement) => str == null ? '' : String(str).replace(search, replacement),
    replaceAll: (str, search, replacement) => str == null ? '' : String(str).replaceAll(search, replacement),
    concat: (...args) => args.map(a => a == null ? '' : String(a)).join(''),
    charAt: (str, index) => str == null ? '' : String(str).charAt(index),
    charCodeAt: (str, index) => str == null ? 0 : String(str).charCodeAt(index),
    repeat: (str, count) => str == null ? '' : String(str).repeat(count),
    padStart: (str, len, pad) => str == null ? '' : String(str).padStart(len, pad),
    padEnd: (str, len, pad) => str == null ? '' : String(str).padEnd(len, pad),

    // Type conversion
    bool: (val) => val != null && String(val).toLowerCase() === 'true',
    boolean: (val) => val != null && String(val).toLowerCase() === 'true',
    integer: (val, radix = 10) => { const n = parseInt(val, radix); return isNaN(n) ? null : n; },
    number: (val) => { const n = parseFloat(val); return isNaN(n) ? null : n; },
    toString: (val) => val == null ? '' : String(val),

    // Array/Collection functions
    split: (str, pattern, limit) => {
        if (str == null) return [];
        try {
            const regex = new RegExp(pattern);
            return limit !== undefined ? str.split(regex, limit) : str.split(regex);
        } catch { return [str]; }
    },
    join: (vals, sep = '') => vals == null ? '' : Array.isArray(vals) ? vals.join(sep) : String(vals),
    array: (...args) => args,
    first: (arr) => Array.isArray(arr) && arr.length > 0 ? arr[0] : null,
    last: (arr) => Array.isArray(arr) && arr.length > 0 ? arr[arr.length - 1] : null,
    reverse: (arr) => Array.isArray(arr) ? [...arr].reverse() : arr,
    sort: (arr) => Array.isArray(arr) ? [...arr].sort() : arr,
    slice: (arr, start, end) => {
        if (arr == null) return [];
        if (typeof arr === 'string') return end !== undefined ? arr.slice(start, end) : arr.slice(start);
        if (Array.isArray(arr)) return end !== undefined ? arr.slice(start, end) : arr.slice(start);
        return [];
    },

    // Object functions
    keys: (obj) => obj == null ? [] : Object.keys(obj),
    keySet: (obj) => obj == null ? [] : Object.keys(obj),
    values: (obj) => obj == null ? [] : Object.values(obj),
    entries: (obj) => obj == null ? [] : Object.entries(obj),

    // Utility functions
    length: (obj) => {
        if (obj == null) return 0;
        if (typeof obj === 'string' || Array.isArray(obj)) return obj.length;
        if (typeof obj === 'object') return Object.keys(obj).length;
        return 0;
    },
    size: (obj) => FUNCTIONS.length(obj),
    indexOf: (str, sub, fromIndex = 0) => str == null || sub == null ? -1 : String(str).indexOf(sub, fromIndex),
    lastIndexOf: (str, sub, fromIndex) => str == null || sub == null ? -1 : (fromIndex !== undefined ? String(str).lastIndexOf(sub, fromIndex) : String(str).lastIndexOf(sub)),
    empty: (val) => val == null || (typeof val === 'string' && val.length === 0) || (Array.isArray(val) && val.length === 0) || (typeof val === 'object' && Object.keys(val).length === 0),
    isEmpty: (val) => FUNCTIONS.empty(val),
    isNull: (val) => val === null || val === undefined,
    isNotNull: (val) => val !== null && val !== undefined,
    defaultTo: (val, defaultVal) => val == null ? defaultVal : val,
    coalesce: (...args) => args.find(a => a != null) ?? null,

    // Encoding functions
    encodeBase64: (str) => str == null ? '' : btoa(unescape(encodeURIComponent(str))),
    decodeBase64: (str) => { try { return decodeURIComponent(escape(atob(str))); } catch { return ''; } },
    urlEncode: (str) => str == null ? '' : encodeURIComponent(str),
    urlDecode: (str) => { try { return decodeURIComponent(str); } catch { return str; } },
    jsonParse: (str) => { try { return JSON.parse(str); } catch { return null; } },
    jsonStringify: (obj) => { try { return JSON.stringify(obj); } catch { return ''; } },

    // Math functions
    abs: (n) => Math.abs(n),
    ceil: (n) => Math.ceil(n),
    floor: (n) => Math.floor(n),
    round: (n) => Math.round(n),
    min: (...args) => Math.min(...args),
    max: (...args) => Math.max(...args),
    random: () => Math.random(),

    // Date/Time functions (simplified)
    now: () => Date.now(),
    timestamp: () => Math.floor(Date.now() / 1000),

    // Official IG functions - URL encoding (org.forgerock.http.util.Uris)
    urlDecodeFragment: (str) => { try { return decodeURIComponent(str); } catch { return str; } },
    urlDecodePathElement: (str) => { try { return decodeURIComponent(str); } catch { return str; } },
    urlDecodeQueryParameterNameOrValue: (str) => { try { return decodeURIComponent(str); } catch { return str; } },
    urlDecodeUserInfo: (str) => { try { return decodeURIComponent(str); } catch { return str; } },
    urlEncodeFragment: (str) => str == null ? '' : encodeURIComponent(str),
    urlEncodePathElement: (str) => str == null ? '' : encodeURIComponent(str),
    urlEncodeQueryParameterNameOrValue: (str) => str == null ? '' : encodeURIComponent(str),
    urlEncodeUserInfo: (str) => str == null ? '' : encodeURIComponent(str),
    formDecodeParameterNameOrValue: (str) => { try { return decodeURIComponent(str?.replace(/\+/g, ' ')); } catch { return str; } },
    formEncodeParameterNameOrValue: (str) => str == null ? '' : encodeURIComponent(str).replace(/%20/g, '+'),

    // Official IG functions - additional
    decodeBase64url: (str) => {
        if (str == null) return null;
        try {
            // Convert base64url to base64
            let base64 = str.replace(/-/g, '+').replace(/_/g, '/');
            while (base64.length % 4) base64 += '=';
            return decodeURIComponent(escape(atob(base64)));
        } catch { return null; }
    },
    encodeBase64url: (str) => {
        if (str == null) return '';
        try {
            return btoa(unescape(encodeURIComponent(str))).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        } catch { return ''; }
    },
    digestSha256: (str) => {
        // Note: Simplified - in browser would need crypto.subtle
        // Returns placeholder; real implementation would need async crypto
        console.warn('digestSha256: Use browser crypto API for real SHA-256');
        return str ? '[SHA-256 hash]' : null;
    },
    toJson: (obj) => { try { return JSON.stringify(obj); } catch { return ''; } },
    keyMatch: (map, pattern) => {
        if (map == null || pattern == null) return null;
        try {
            const regex = new RegExp(pattern);
            for (const key of Object.keys(map)) {
                if (regex.test(key)) return key;
            }
        } catch { }
        return null;
    },
    ipMatch: (ip, cidr) => {
        if (ip == null || cidr == null) return false;
        try {
            // Simple IPv4 CIDR matching
            const [range, bits] = cidr.split('/');
            const mask = bits ? (-1 << (32 - parseInt(bits))) >>> 0 : 0xFFFFFFFF;
            const ipToInt = (ipStr) => ipStr.split('.').reduce((acc, oct) => (acc << 8) + parseInt(oct), 0) >>> 0;
            return (ipToInt(ip) & mask) === (ipToInt(range) & mask);
        } catch { return false; }
    },
    integerWithRadix: (val, radix) => { const n = parseInt(val, radix); return isNaN(n) ? null : n; },
};

// ============== Evaluator ==============
class Evaluator {
    constructor(context) { this.context = context; this.traces = []; }

    evaluate(ast) {
        try {
            const value = this.visit(ast);
            return { success: true, value, traces: this.traces };
        } catch (e) {
            return { success: false, error: e.message, traces: this.traces };
        }
    }

    visit(node) {
        switch (node.type) {
            case 'Expression': return this.visit(node.body);
            case 'BinaryOp': return this.visitBinaryOp(node);
            case 'UnaryOp': return this.visitUnaryOp(node);
            case 'TernaryOp': return this.visitTernaryOp(node);
            case 'FunctionCall': return this.visitFunctionCall(node);
            case 'MethodCall': return this.visitMethodCall(node);
            case 'PropertyAccess': return this.visitPropertyAccess(node);
            case 'IndexAccess': return this.visitIndexAccess(node);
            case 'Identifier': return this.visitIdentifier(node);
            case 'Literal': return node.value;
            default: throw new Error(`Unknown node type: ${node.type}`);
        }
    }

    visitBinaryOp(node) {
        const left = this.visit(node.left);
        const right = this.visit(node.right);
        let result;
        switch (node.operator) {
            case 'and': result = Boolean(left) && Boolean(right); break;
            case 'or': result = Boolean(left) || Boolean(right); break;
            case '==': result = left === right; break;
            case '!=': result = left !== right; break;
            case '<': result = left < right; break;
            case '<=': result = left <= right; break;
            case '>': result = left > right; break;
            case '>=': result = left >= right; break;
            case '+': result = (typeof left === 'string' || typeof right === 'string') ? String(left ?? '') + String(right ?? '') : (left ?? 0) + (right ?? 0); break;
            case '-': result = (left ?? 0) - (right ?? 0); break;
            case '*': result = (left ?? 0) * (right ?? 0); break;
            case '/': result = (left ?? 0) / right; break;
            case '%': result = (left ?? 0) % right; break;
            default: throw new Error(`Unknown operator: ${node.operator}`);
        }
        this.traces.push({ node, left, right, result, operator: node.operator });
        return result;
    }

    visitUnaryOp(node) {
        const operand = this.visit(node.operand);
        let result;
        switch (node.operator) {
            case 'not': result = !Boolean(operand); break;
            case '-': result = -(operand ?? 0); break;
            case 'empty': result = operand == null || (operand.length !== undefined && operand.length === 0); break;
            default: throw new Error(`Unknown unary operator: ${node.operator}`);
        }
        this.traces.push({ node, operand, result, operator: node.operator });
        return result;
    }

    visitTernaryOp(node) {
        const cond = this.visit(node.condition);
        return cond ? this.visit(node.thenExpr) : this.visit(node.elseExpr);
    }

    visitFunctionCall(node) {
        const fn = FUNCTIONS[node.name];
        if (!fn) throw new Error(`Unknown function: ${node.name}`);
        const args = node.arguments.map(a => this.visit(a));
        const result = fn(...args);
        this.traces.push({ node, name: node.name, args, result });
        return result;
    }

    visitMethodCall(node) {
        const obj = this.visit(node.object);
        const args = node.arguments.map(a => this.visit(a));
        const method = node.method;
        let result;

        // String methods
        const STRING_METHODS = {
            length: (s) => s == null ? 0 : String(s).length,
            toLowerCase: (s) => s == null ? '' : String(s).toLowerCase(),
            toUpperCase: (s) => s == null ? '' : String(s).toUpperCase(),
            trim: (s) => s == null ? '' : String(s).trim(),
            trimStart: (s) => s == null ? '' : String(s).trimStart(),
            trimEnd: (s) => s == null ? '' : String(s).trimEnd(),
            substring: (s, start, end) => s == null ? '' : (end !== undefined ? String(s).substring(start, end) : String(s).substring(start)),
            substr: (s, start, len) => s == null ? '' : (len !== undefined ? String(s).substr(start, len) : String(s).substr(start)),
            charAt: (s, i) => s == null ? '' : String(s).charAt(i),
            charCodeAt: (s, i) => s == null ? 0 : String(s).charCodeAt(i),
            indexOf: (s, sub, from) => s == null ? -1 : (from !== undefined ? String(s).indexOf(sub, from) : String(s).indexOf(sub)),
            lastIndexOf: (s, sub, from) => s == null ? -1 : (from !== undefined ? String(s).lastIndexOf(sub, from) : String(s).lastIndexOf(sub)),
            startsWith: (s, prefix) => s == null ? false : String(s).startsWith(prefix),
            endsWith: (s, suffix) => s == null ? false : String(s).endsWith(suffix),
            includes: (s, sub) => s == null ? false : String(s).includes(sub),
            contains: (s, sub) => s == null ? false : String(s).includes(sub),
            split: (s, sep, limit) => s == null ? [] : (limit !== undefined ? String(s).split(sep, limit) : String(s).split(sep)),
            replace: (s, search, repl) => s == null ? '' : String(s).replace(search, repl),
            replaceAll: (s, search, repl) => s == null ? '' : String(s).replaceAll(search, repl),
            repeat: (s, count) => s == null ? '' : String(s).repeat(count),
            padStart: (s, len, pad) => s == null ? '' : String(s).padStart(len, pad || ' '),
            padEnd: (s, len, pad) => s == null ? '' : String(s).padEnd(len, pad || ' '),
            concat: (s, ...more) => s == null ? '' : String(s).concat(...more),
            match: (s, pattern) => { try { return s == null ? null : String(s).match(new RegExp(pattern)); } catch { return null; } },
            toString: (s) => s == null ? '' : String(s),
        };

        // Array methods
        const ARRAY_METHODS = {
            length: (a) => a == null ? 0 : a.length,
            size: (a) => a == null ? 0 : a.length,
            first: (a) => a == null || a.length === 0 ? null : a[0],
            last: (a) => a == null || a.length === 0 ? null : a[a.length - 1],
            get: (a, i) => a == null ? null : a[i],
            indexOf: (a, val) => a == null ? -1 : a.indexOf(val),
            contains: (a, val) => a == null ? false : a.includes(val),
            includes: (a, val) => a == null ? false : a.includes(val),
            join: (a, sep) => a == null ? '' : a.join(sep ?? ''),
            slice: (a, start, end) => a == null ? [] : (end !== undefined ? a.slice(start, end) : a.slice(start)),
            reverse: (a) => a == null ? [] : [...a].reverse(),
            sort: (a) => a == null ? [] : [...a].sort(),
            isEmpty: (a) => a == null || a.length === 0,
        };

        // Object/Map methods
        const OBJECT_METHODS = {
            keys: (o) => o == null ? [] : Object.keys(o),
            keySet: (o) => o == null ? [] : Object.keys(o),
            values: (o) => o == null ? [] : Object.values(o),
            entries: (o) => o == null ? [] : Object.entries(o),
            size: (o) => o == null ? 0 : Object.keys(o).length,
            get: (o, key) => o == null ? null : o[key],
            containsKey: (o, key) => o == null ? false : key in o,
            containsValue: (o, val) => o == null ? false : Object.values(o).includes(val),
            isEmpty: (o) => o == null || Object.keys(o).length === 0,
        };

        // Try to find and execute the method
        if (typeof obj === 'string' && STRING_METHODS[method]) {
            result = STRING_METHODS[method](obj, ...args);
        } else if (Array.isArray(obj) && ARRAY_METHODS[method]) {
            result = ARRAY_METHODS[method](obj, ...args);
        } else if (obj !== null && typeof obj === 'object' && OBJECT_METHODS[method]) {
            result = OBJECT_METHODS[method](obj, ...args);
        } else if (obj != null && typeof obj[method] === 'function') {
            // Try native method
            result = obj[method](...args);
        } else if (FUNCTIONS[method]) {
            // Fall back to global function with obj as first argument
            result = FUNCTIONS[method](obj, ...args);
        } else {
            throw new Error(`Unknown method: ${method}`);
        }

        this.traces.push({ node, object: obj, method, args, result });
        return result;
    }

    visitPropertyAccess(node) {
        const obj = this.visit(node.object);
        if (obj == null) return null;
        // Special handling for .length property on strings/arrays
        if (node.property === 'length' && (typeof obj === 'string' || Array.isArray(obj))) {
            return obj.length;
        }
        return obj[node.property];
    }

    visitIndexAccess(node) {
        const obj = this.visit(node.object);
        const index = this.visit(node.index);
        if (obj == null) return null;
        return obj[index];
    }

    visitIdentifier(node) {
        return this.context[node.name];
    }
}

// ============== Diagnoser ==============
function diagnose(condition, request) {
    // Parse form data if content-type is application/x-www-form-urlencoded
    const parseFormData = (body, contentType) => {
        if (!body || !contentType) return {};
        if (contentType.includes('application/x-www-form-urlencoded')) {
            return parseQueryParams(body);
        }
        return {};
    };

    const contentType = request.headers['Content-Type']?.[0] || request.headers['content-type']?.[0] || '';
    const formData = parseFormData(request.body, contentType);

    // Build comprehensive context matching IG's runtime
    const context = {
        // Main request object
        request: {
            method: request.method,
            uri: {
                scheme: 'https',
                host: request.host,
                port: 443,
                path: request.path,
                query: request.query,
                fragment: '',
                // Full URL reconstruction
                toString: () => `https://${request.host}${request.path}${request.query ? '?' + request.query : ''}`,
            },
            headers: request.headers,
            cookies: request.cookies,
            form: formData,
            entity: {
                string: request.body,
                json: (() => { try { return JSON.parse(request.body); } catch { return null; } })(),
                bytes: request.body ? new TextEncoder().encode(request.body) : null,
            },
            queryParams: parseQueryParams(request.query),
        },

        // Session object (simulated)
        session: {
            // Common session properties
            sessionId: 'simulated-session-id',
            // Session can store arbitrary properties
        },

        // Attributes (request-scoped storage)
        attributes: {
            // Attributes can store arbitrary properties
        },

        // Contexts object (IG-specific)
        contexts: {
            // Router context
            router: {
                name: 'default',
                baseUri: '/',
            },
            // Client context (info about client connection)
            client: {
                remoteAddress: '127.0.0.1',
                remotePort: 12345,
                localAddress: '127.0.0.1',
                localPort: 443,
                isSecure: true,
                certificates: [],
            },
            // OAuth2 context (if present)
            oauth2: {
                accessToken: null,
                tokenInfo: {},
            },
            // AM (Access Management) context
            amSession: {
                sessionId: null,
                realm: '/',
                username: null,
            },
            // JWT context
            jwtSession: {
                claims: {},
            },
        },

        // Environment variables
        env: {
            // System environment variables can be accessed here
        },

        // System properties
        system: {
            // Java system properties (simulated)
        },

        // Heap storage (cross-request)
        heap: {},

        // True/false/null literals for convenience
        true: true,
        false: false,
        null: null,
    };

    let ast;
    try {
        ast = new Parser(condition).parse();
    } catch (e) {
        return { success: false, error: e.message, conditions: [] };
    }

    const evaluator = new Evaluator(context);
    const result = evaluator.evaluate(ast);

    if (!result.success) {
        return { success: false, error: result.error, conditions: [] };
    }

    const conditions = analyzeConditions(ast.body, context);
    const passed = conditions.filter(c => c.passed).length;

    // Check for performance issues
    const performanceTips = checkPerformance(condition);

    return {
        success: true,
        overall: Boolean(result.value),
        conditions,
        performanceTips,
        summary: `${passed}/${conditions.length} conditions passed`
    };
}

function analyzeConditions(node, context, depth = 0) {
    const results = [];

    if (node.type === 'BinaryOp' && node.operator === 'and') {
        // AND: expand as independent conditions
        results.push(...analyzeConditions(node.left, context, depth));
        results.push(...analyzeConditions(node.right, context, depth));
    } else if (node.type === 'BinaryOp' && node.operator === 'or') {
        // OR: treat as a group, show each branch
        const evaluator = new Evaluator(context);
        const value = evaluator.visit(node);
        const branches = collectOrBranches(node);
        const branchResults = branches.map(b => {
            const branchEval = new Evaluator(context);
            const branchValue = branchEval.visit(b);
            // For AND expressions, collect details from sub-conditions
            const subDetails = collectSubDetails(b, context);
            const details = generateDetails(b, branchValue, context);
            return {
                expression: nodeToString(b),
                passed: Boolean(branchValue),
                details: details.details,
                suggestion: details.suggestion,
                subDetails: subDetails
            };
        });

        results.push({
            expression: nodeToString(node),
            passed: Boolean(value),
            value,
            isOrGroup: true,
            branches: branchResults,
            details: `OR group: ${branchResults.filter(b => b.passed).length}/${branchResults.length} branches match`,
            suggestion: ''
        });
    } else {
        const evaluator = new Evaluator(context);
        const value = evaluator.visit(node);
        const exprStr = nodeToString(node);
        const details = generateDetails(node, value, context);

        results.push({
            expression: exprStr,
            passed: Boolean(value),
            value,
            details: details.details,
            suggestion: details.suggestion
        });
    }

    return results;
}

function collectOrBranches(node) {
    if (node.type === 'BinaryOp' && node.operator === 'or') {
        return [...collectOrBranches(node.left), ...collectOrBranches(node.right)];
    }
    return [node];
}

// Collect detailed info from sub-conditions (for AND expressions)
function collectSubDetails(node, context) {
    const results = [];

    function collect(n) {
        if (n.type === 'BinaryOp' && n.operator === 'and') {
            collect(n.left);
            collect(n.right);
        } else if (n.type === 'BinaryOp' && n.operator === 'or') {
            // OR chain - collect all branches and show as a group
            const orBranches = collectOrBranches(n);
            const evaluator = new Evaluator(context);
            const overallValue = evaluator.visit(n);

            // Find which branch matched (if any)
            const branchResults = orBranches.map(b => {
                const branchEval = new Evaluator(context);
                const value = branchEval.visit(b);
                return {
                    expression: nodeToString(b),
                    passed: Boolean(value),
                    node: b
                };
            });

            const passedBranch = branchResults.find(b => b.passed);

            // Create a summary for the OR group
            let orSummary;
            if (passedBranch) {
                // Show which one matched
                const details = generateDetails(passedBranch.node, true, context);
                orSummary = {
                    expression: `OR (${branchResults.length} options)`,
                    passed: true,
                    details: details.details,
                    matchedPattern: getShortDescFromNode(passedBranch.node)
                };
            } else {
                orSummary = {
                    expression: `OR (${branchResults.length} options)`,
                    passed: false,
                    details: `None of ${branchResults.length} patterns matched`
                };
            }
            results.push(orSummary);
        } else if (n.type === 'FunctionCall' || n.type === 'MethodCall') {
            const evaluator = new Evaluator(context);
            const value = evaluator.visit(n);
            const details = generateDetails(n, value, context);
            results.push({
                expression: nodeToString(n),
                passed: Boolean(value),
                details: details.details
            });
        } else if (n.type === 'BinaryOp') {
            // Comparison operators
            const evaluator = new Evaluator(context);
            const value = evaluator.visit(n);
            const details = generateDetails(n, value, context);
            results.push({
                expression: nodeToString(n),
                passed: Boolean(value),
                details: details.details
            });
        }
    }

    collect(node);
    return results;
}

// Helper to get short description from AST node
function getShortDescFromNode(node) {
    if (node.type === 'FunctionCall' && node.arguments.length >= 2) {
        const arg = node.arguments[1];
        if (arg.type === 'Literal' && arg.litType === 'string') {
            const val = arg.value;
            return val.length > 50 ? val.slice(0, 47) + '...' : val;
        }
    }
    const expr = nodeToString(node);
    return expr.length > 50 ? expr.slice(0, 47) + '...' : expr;
}

function nodeToString(node, parentOp = null) {
    switch (node.type) {
        case 'BinaryOp': {
            const inner = `${nodeToString(node.left, node.operator)} ${node.operator} ${nodeToString(node.right, node.operator)}`;
            // Only add parens if parent has different precedence
            const needsParens = parentOp && parentOp !== node.operator &&
                ((parentOp === 'and' && node.operator === 'or') || (parentOp === 'or' && node.operator === 'and'));
            return needsParens ? `(${inner})` : inner;
        }
        case 'UnaryOp': return `${node.operator} ${nodeToString(node.operand)}`;
        case 'FunctionCall': return `${node.name}(${node.arguments.map(a => nodeToString(a)).join(', ')})`;
        case 'MethodCall': return `${nodeToString(node.object)}.${node.method}(${node.arguments.map(a => nodeToString(a)).join(', ')})`;
        case 'PropertyAccess': return `${nodeToString(node.object)}.${node.property}`;
        case 'IndexAccess': return `${nodeToString(node.object)}[${nodeToString(node.index)}]`;
        case 'Identifier': return node.name;
        case 'Literal': return node.litType === 'string' ? `'${node.value}'` : String(node.value);
        case 'Ternary': return `${nodeToString(node.condition)} ? ${nodeToString(node.consequent)} : ${nodeToString(node.alternate)}`;
        default: return '?';
    }
}

function generateDetails(node, value, context) {
    let details = '', suggestion = '';

    // Helper to escape HTML
    const esc = (s) => String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

    // Helper to format value with highlighting
    const hval = (val) => {
        if (val === true) return '<span class="val-true">true</span>';
        if (val === false) return '<span class="val-false">false</span>';
        if (val === null || val === undefined) return '<span class="val-false">null</span>';
        if (typeof val === 'string') return `<span class="fn-arg">"${esc(val)}"</span>`;
        if (typeof val === 'number') return `<span class="fn-result">${val}</span>`;
        if (Array.isArray(val)) return `<span class="fn-arg">${esc(JSON.stringify(val))}</span>`;
        if (typeof val === 'object') return `<span class="fn-arg">${esc(JSON.stringify(val))}</span>`;
        return esc(String(val));
    };

    if (node.type === 'BinaryOp') {
        const leftVal = new Evaluator(context).visit(node.left);
        const rightVal = new Evaluator(context).visit(node.right);

        if (node.operator === 'and' || node.operator === 'or') {
            // For logical operators, show which side(s) failed/passed
            const leftBool = Boolean(leftVal);
            const rightBool = Boolean(rightVal);
            const opHtml = `<span class="op">${node.operator}</span>`;
            if (node.operator === 'and') {
                if (!leftBool && !rightBool) {
                    details = `${hval(false)} ${opHtml} ${hval(false)} → Both conditions are false`;
                } else if (!leftBool) {
                    details = `${hval(false)} ${opHtml} ${hval(true)} → Left condition is false`;
                } else if (!rightBool) {
                    details = `${hval(true)} ${opHtml} ${hval(false)} → Right condition is false`;
                } else {
                    details = `${hval(true)} ${opHtml} ${hval(true)} → Both conditions are true`;
                }
            } else { // or
                if (leftBool || rightBool) {
                    details = `${hval(leftBool)} ${opHtml} ${hval(rightBool)} → ${leftBool ? 'Left' : 'Right'} condition is true`;
                } else {
                    details = `${hval(false)} ${opHtml} ${hval(false)} → Both conditions are false`;
                }
            }
        } else {
            // For comparison operators, show actual values
            const opHtml = `<span class="op">${esc(node.operator)}</span>`;

            // Special handling for != null checks (common pattern for "exists" check)
            if ((node.operator === '!=' || node.operator === 'ne') && rightVal === null) {
                if (leftVal === null || leftVal === undefined) {
                    details = `Value is <span class="val-false">null</span> (not found)`;
                    // Try to give a hint about what's missing
                    const leftExpr = nodeToString(node.left);
                    if (leftExpr.includes('headers')) {
                        suggestion = `Header not found in request`;
                    } else if (leftExpr.includes('cookies')) {
                        suggestion = `Cookie not found in request`;
                    }
                } else {
                    details = `Value exists: ${hval(leftVal)}`;
                }
            } else if ((node.operator === '==' || node.operator === 'eq') && rightVal === null) {
                if (leftVal === null || leftVal === undefined) {
                    details = `Value is <span class="val-true">null</span> (not found, as expected)`;
                } else {
                    details = `Value exists: ${hval(leftVal)} (expected null)`;
                }
            } else {
                details = `${hval(leftVal)} ${opHtml} ${hval(rightVal)}`;
                if (node.operator === '==' && leftVal !== rightVal) {
                    suggestion = `Expected ${hval(rightVal)}, but got ${hval(leftVal)}`;
                }
            }
        }
    } else if (node.type === 'FunctionCall') {
        const args = node.arguments.map(a => new Evaluator(context).visit(a));
        const fnName = `<span class="fn-name">${esc(node.name)}</span>`;
        const resultHtml = hval(value);

        // For string matching functions, highlight the matched portion
        const matchFuncs = ['matches', 'contains', 'find', 'matchesWithRegex', 'findGroups', 'startsWith', 'endsWith'];
        if (matchFuncs.includes(node.name) && args.length >= 2) {
            const haystack = String(args[0] || '');
            const needle = String(args[1] || '');
            const matched = value && (typeof value === 'boolean' ? value : value !== null);

            if (matched && needle) {
                // Match found - highlight the matched portion
                let highlightedHaystack;
                try {
                    if (node.name === 'contains') {
                        // Simple substring match
                        const idx = haystack.indexOf(needle);
                        if (idx >= 0) {
                            const before = esc(haystack.slice(0, idx));
                            const match = esc(haystack.slice(idx, idx + needle.length));
                            const after = esc(haystack.slice(idx + needle.length));
                            highlightedHaystack = `<span class="fn-arg">"${before}<span class="match-highlight">${match}</span>${after}"</span>`;
                        } else {
                            highlightedHaystack = hval(haystack);
                        }
                    } else if (node.name === 'startsWith') {
                        // Prefix match
                        if (haystack.startsWith(needle)) {
                            const match = esc(needle);
                            const after = esc(haystack.slice(needle.length));
                            highlightedHaystack = `<span class="fn-arg">"<span class="match-highlight">${match}</span>${after}"</span>`;
                        } else {
                            highlightedHaystack = hval(haystack);
                        }
                    } else if (node.name === 'endsWith') {
                        // Suffix match
                        if (haystack.endsWith(needle)) {
                            const before = esc(haystack.slice(0, -needle.length));
                            const match = esc(needle);
                            highlightedHaystack = `<span class="fn-arg">"${before}<span class="match-highlight">${match}</span>"</span>`;
                        } else {
                            highlightedHaystack = hval(haystack);
                        }
                    } else if (node.name === 'matchesWithRegex') {
                        // Full regex match - the entire string should match
                        const regex = new RegExp('^' + needle + '$');
                        if (regex.test(haystack)) {
                            highlightedHaystack = `<span class="fn-arg">"<span class="match-highlight">${esc(haystack)}</span>"</span>`;
                        } else {
                            highlightedHaystack = hval(haystack);
                        }
                    } else {
                        // Regex match (matches/find/findGroups)
                        const regex = new RegExp(needle);
                        const match = haystack.match(regex);
                        if (match && match[0]) {
                            const idx = haystack.indexOf(match[0]);
                            const before = esc(haystack.slice(0, idx));
                            const matchStr = esc(match[0]);
                            const after = esc(haystack.slice(idx + match[0].length));
                            highlightedHaystack = `<span class="fn-arg">"${before}<span class="match-highlight">${matchStr}</span>${after}"</span>`;
                        } else {
                            highlightedHaystack = hval(haystack);
                        }
                    }
                } catch (e) {
                    highlightedHaystack = hval(haystack);
                }
                details = `${fnName}(${highlightedHaystack}, ${hval(needle)}) → ${resultHtml}`;
            } else {
                // No match
                details = `${fnName}(${hval(haystack)}, ${hval(needle)}) → ${resultHtml}`;
                suggestion = `Pattern ${hval(needle)} not found in ${hval(haystack)}`;
            }
        } else {
            const argsHtml = args.map(hval).join(', ');
            details = `${fnName}(${argsHtml}) → ${resultHtml}`;
        }
    } else if (node.type === 'UnaryOp') {
        const operand = new Evaluator(context).visit(node.operand);
        const opHtml = `<span class="op">${esc(node.operator)}</span>`;
        details = `${opHtml} ${hval(operand)} → ${hval(value)}`;
    }

    return { details, suggestion, isHtml: true };
}

function repr(val) {
    if (val === null || val === undefined) return 'null';
    if (typeof val === 'string') return `"${val}"`;
    if (typeof val === 'boolean') return val ? 'true' : 'false';
    if (Array.isArray(val)) return JSON.stringify(val);
    if (typeof val === 'object') return JSON.stringify(val);
    return String(val);
}

function parseQueryParams(query) {
    if (!query) return {};
    const params = {};
    query.split('&').forEach(pair => {
        const [key, value] = pair.split('=');
        if (key) {
            if (!params[key]) params[key] = [];
            params[key].push(decodeURIComponent(value || ''));
        }
    });
    return params;
}

function parseCurl(curlCmd) {
    const request = { method: 'GET', path: '/', query: '', host: '', headers: {}, cookies: {}, body: null };

    // Handle multiline cURL: remove backslash-newline continuations and normalize whitespace
    // Also handle Windows-style line endings and caret (^) continuations
    const cleaned = curlCmd
        .replace(/\^\r?\n/g, ' ')      // Windows caret continuation
        .replace(/\\\r?\n/g, ' ')      // Unix backslash continuation
        .replace(/\r?\n/g, ' ')        // Plain newlines (compressed cURL)
        .replace(/\s+/g, ' ')          // Normalize whitespace
        .trim();

    // Check if input is just a URL (not a curl command)
    if (cleaned.match(/^https?:\/\/[^\s]+$/) && !cleaned.startsWith('curl')) {
        return parseUrl(cleaned);
    }

    const args = [];
    let current = '', inQuote = null, escapeNext = false;

    for (let i = 0; i < cleaned.length; i++) {
        const c = cleaned[i];
        if (escapeNext) {
            current += c;
            escapeNext = false;
        } else if (c === '\\' && inQuote !== "'") {
            // Backslash escapes next char (except in single quotes)
            escapeNext = true;
        } else if (inQuote) {
            if (c === inQuote) inQuote = null;
            else current += c;
        } else if (c === '"' || c === "'") {
            inQuote = c;
        } else if (c === ' ') {
            if (current) { args.push(current); current = ''; }
        } else {
            current += c;
        }
    }
    if (current) args.push(current);

    // Collect data parts for combining multiple -d flags
    const dataParts = [];
    const dataUrlencodeParts = [];

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];

        // Method
        if (arg === '-X' || arg === '--request') {
            request.method = args[++i]?.toUpperCase() || 'GET';
        }
        // Headers
        else if (arg === '-H' || arg === '--header') {
            const header = args[++i] || '';
            const idx = header.indexOf(':');
            if (idx > 0) {
                const name = header.slice(0, idx).trim();
                const value = header.slice(idx + 1).trim();
                // Handle Cookie header specially
                if (name.toLowerCase() === 'cookie') {
                    parseCookieString(value, request.cookies);
                } else {
                    if (!request.headers[name]) request.headers[name] = [];
                    request.headers[name].push(value);
                }
            }
        }
        // Cookies (-b / --cookie)
        else if (arg === '-b' || arg === '--cookie') {
            const cookieVal = args[++i] || '';
            // Could be a cookie string or a file path (file paths start with @)
            if (!cookieVal.startsWith('@')) {
                parseCookieString(cookieVal, request.cookies);
            }
        }
        // Data flags
        else if (arg === '-d' || arg === '--data' || arg === '--data-raw' || arg === '--data-binary') {
            dataParts.push(args[++i] || '');
            if (request.method === 'GET') request.method = 'POST';
        }
        // URL-encoded data
        else if (arg === '--data-urlencode') {
            dataUrlencodeParts.push(args[++i] || '');
            if (request.method === 'GET') request.method = 'POST';
        }
        // Data from file (just note it, can't actually read file)
        else if (arg === '--data-ascii') {
            dataParts.push(args[++i] || '');
            if (request.method === 'GET') request.method = 'POST';
        }
        // URL
        else if (arg.startsWith('http://') || arg.startsWith('https://')) {
            const parsed = parseUrl(arg);
            request.host = parsed.host;
            request.path = parsed.path;
            request.query = parsed.query;
        }
        // --url flag
        else if (arg === '--url') {
            const urlArg = args[++i] || '';
            if (urlArg.startsWith('http://') || urlArg.startsWith('https://')) {
                const parsed = parseUrl(urlArg);
                request.host = parsed.host;
                request.path = parsed.path;
                request.query = parsed.query;
            }
        }
    }

    // Combine data parts
    if (dataParts.length > 0) {
        request.body = dataParts.join('&');
    }

    // Handle --data-urlencode parts
    if (dataUrlencodeParts.length > 0) {
        const encodedParts = dataUrlencodeParts.map(part => {
            // Format: name=content, =content, name@filename, or just content
            if (part.includes('=')) {
                const eqIdx = part.indexOf('=');
                const name = part.slice(0, eqIdx);
                const value = part.slice(eqIdx + 1);
                if (name) {
                    return `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
                } else {
                    return encodeURIComponent(value);
                }
            } else {
                return encodeURIComponent(part);
            }
        });

        if (request.body) {
            request.body += '&' + encodedParts.join('&');
        } else {
            request.body = encodedParts.join('&');
        }
    }

    return request;
}

// Parse cookie string (name=value; name2=value2) into cookies object
function parseCookieString(cookieStr, cookies) {
    if (!cookieStr) return;
    cookieStr.split(';').forEach(pair => {
        const trimmed = pair.trim();
        const eqIdx = trimmed.indexOf('=');
        if (eqIdx > 0) {
            const name = trimmed.slice(0, eqIdx).trim();
            const value = trimmed.slice(eqIdx + 1).trim();
            cookies[name] = value;
        }
    });
}

function parseUrl(urlStr) {
    const request = { method: 'GET', path: '/', query: '', host: '', headers: {}, cookies: {}, body: null };
    try {
        const url = new URL(urlStr);
        request.host = url.hostname;
        // Query string: decode it so conditions can match actual values
        // e.g., %3CAdvices%3E becomes <Advices>
        const rawQuery = url.search ? url.search.slice(1) : '';
        try {
            request.query = decodeURIComponent(rawQuery);
        } catch (e) {
            // If decoding fails (malformed %), keep original
            request.query = rawQuery;
        }
        // Path: decode it (IG's request.uri.path is decoded)
        // url.pathname is already decoded by the URL parser
        request.path = url.pathname || '/';
    } catch (e) {
        console.error('Failed to parse URL:', e);
    }
    return request;
}

// ============== UI ==============
// Store parsed request data
let currentRequest = {
    method: 'GET',
    path: '/',
    query: '',
    host: '',
    headers: {},
    cookies: {},
    body: null
};

// ============== Syntax Validation ==============
// Known valid property paths for request object
const VALID_REQUEST_PROPS = {
    'request': ['method', 'uri', 'headers', 'cookies', 'form', 'entity', 'queryParams'],
    'request.uri': ['path', 'query', 'host', 'scheme', 'port', 'toString'],
    'request.entity': ['string', 'json', 'bytes'],
    'contexts': ['router', 'client', 'oauth2', 'amSession', 'jwtSession'],
    'contexts.client': ['remoteAddress', 'remotePort', 'localAddress', 'localPort', 'isSecure', 'certificates'],
};

// Simple Levenshtein distance for typo detection
function levenshtein(a, b) {
    const matrix = [];
    for (let i = 0; i <= b.length; i++) matrix[i] = [i];
    for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
    for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
            matrix[i][j] = b[i-1] === a[j-1]
                ? matrix[i-1][j-1]
                : Math.min(matrix[i-1][j-1] + 1, matrix[i][j-1] + 1, matrix[i-1][j] + 1);
        }
    }
    return matrix[b.length][a.length];
}

// Known root objects in IG expressions
const VALID_ROOT_OBJECTS = ['request', 'contexts', 'session', 'attributes', 'env', 'system', 'heap', 'true', 'false', 'null'];

// Get line and column from position in text
function getLineCol(text, pos) {
    const before = text.substring(0, pos);
    const lines = before.split('\n');
    return { line: lines.length, col: lines[lines.length - 1].length + 1 };
}

// Check for common typos and invalid properties
function checkSemantics(text) {
    const warnings = [];

    // Check for typos in root objects (e.g., requests instead of request)
    const rootPattern = /\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\./g;
    let rootMatch;
    while ((rootMatch = rootPattern.exec(text)) !== null) {
        const rootName = rootMatch[1];
        if (!VALID_ROOT_OBJECTS.includes(rootName)) {
            const similar = VALID_ROOT_OBJECTS.find(v => levenshtein(v.toLowerCase(), rootName.toLowerCase()) <= 2);
            if (similar) {
                const pos = getLineCol(text, rootMatch.index);
                warnings.push({ msg: `'${rootName}' might be a typo. Did you mean '${similar}'?`, line: pos.line, col: pos.col });
            }
        }
    }

    // Check property paths
    const propPattern = /\b(request|contexts)(\.[a-zA-Z_][a-zA-Z0-9_]*)+/g;
    let match;

    while ((match = propPattern.exec(text)) !== null) {
        const fullPath = match[0];
        const parts = fullPath.split('.');

        let charOffset = match.index;
        for (let i = 0; i < parts.length - 1; i++) {
            charOffset += parts[i].length + 1; // +1 for the dot
            const parentPath = parts.slice(0, i + 1).join('.');
            const childProp = parts[i + 1];

            if (['headers', 'cookies', 'form', 'queryParams'].includes(parts[i])) break;

            const validChildren = VALID_REQUEST_PROPS[parentPath];
            if (validChildren && !validChildren.includes(childProp)) {
                const pos = getLineCol(text, charOffset);
                const similar = validChildren.find(v => levenshtein(v.toLowerCase(), childProp.toLowerCase()) <= 2);
                if (similar) {
                    warnings.push({ msg: `'${childProp}' might be a typo. Did you mean '${similar}'?`, line: pos.line, col: pos.col });
                } else {
                    warnings.push({ msg: `'${childProp}' is not a known property of '${parentPath}'. Valid: ${validChildren.join(', ')}`, line: pos.line, col: pos.col });
                }
                break;
            }
        }
    }
    return warnings;
}

// Check for performance issues and best practices in expressions
function checkPerformance(text) {
    const tips = [];
    let match;

    // 1. Detect catastrophic backtracking patterns (CRITICAL - can hang IG)
    const allRegexPattern = /(?:matches|find|matchesWithRegex)\s*\([^,]+,\s*['"]([^'"]+)['"]\)/g;
    while ((match = allRegexPattern.exec(text)) !== null) {
        const pattern = match[1];
        // Nested quantifiers: (a+)+ or (a*)*  - can cause exponential backtracking
        if (/\([^)]*[+*]\)[+*]/.test(pattern) || /[+*][^)]*\([^)]*[+*]\)/.test(pattern)) {
            tips.push({
                type: 'regex',
                msg: `Dangerous pattern: nested quantifiers in "${pattern.substring(0, 40)}${pattern.length > 40 ? '...' : ''}" can cause catastrophic backtracking and hang the server.`,
                severity: 'warning'
            });
        }
        // Overlapping alternatives with quantifiers: (a|a)+
        if (/\([^)]*\|[^)]*\)[+*]/.test(pattern) && /(\w)\|.*\1/.test(pattern)) {
            tips.push({
                type: 'regex',
                msg: `Pattern has overlapping alternatives with quantifiers - may cause exponential time complexity.`,
                severity: 'warning'
            });
        }
    }

    // 2. Detect matches() when contains() or startsWith()/endsWith() would suffice
    const matchesPattern = /matches\s*\([^,]+,\s*['"]([^'"]+)['"]\)/g;
    while ((match = matchesPattern.exec(text)) !== null) {
        const pattern = match[1];
        // .*literal.* -> contains()
        if (/^\.\*[^.*+?\\()\[\]{}^$|]+\.\*$/.test(pattern)) {
            const literal = pattern.slice(2, -2);
            tips.push({
                type: 'optimization',
                msg: `Use contains(..., "${literal}") instead of matches(..., ".*${literal}.*") - simpler and clearer.`,
                severity: 'info'
            });
        }
        // ^literal.* -> startsWith()
        else if (/^\^[^.*+?\\()\[\]{}^$|]+\.\*$/.test(pattern)) {
            const literal = pattern.slice(1, -2);
            tips.push({
                type: 'optimization',
                msg: `Use startsWith(..., "${literal}") instead of matches(..., "^${literal}.*") - more readable.`,
                severity: 'info'
            });
        }
        // .*literal$ -> endsWith()
        else if (/^\.\*[^.*+?\\()\[\]{}^$|]+\$$/.test(pattern)) {
            const literal = pattern.slice(2, -1);
            tips.push({
                type: 'optimization',
                msg: `Use endsWith(..., "${literal}") instead of matches(..., ".*${literal}$") - more readable.`,
                severity: 'info'
            });
        }
    }

    // 3. Detect find() vs matches() confusion
    // find() does partial match, matches() requires full string match in IG
    const findWithAnchors = /find\s*\([^,]+,\s*['"]\^[^'"]*\$['"]\)/g;
    if (findWithAnchors.test(text)) {
        tips.push({
            type: 'correctness',
            msg: `find() with ^...$ anchors: consider using matches() instead. find() does partial match, matches() requires full string match.`,
            severity: 'info'
        });
    }

    // 4. Detect case-insensitive comparison without toLowerCase()
    // e.g., request.method == "get" (should be "GET" or use toLowerCase())
    const methodCheck = /request\.method\s*==\s*['"]([^'"]+)['"]/g;
    while ((match = methodCheck.exec(text)) !== null) {
        const method = match[1];
        if (method !== method.toUpperCase()) {
            tips.push({
                type: 'correctness',
                msg: `HTTP method "${method}" should be uppercase "${method.toUpperCase()}". Methods are case-sensitive in IG.`,
                severity: 'warning'
            });
        }
    }

    // 5. Detect deeply nested conditions (readability issue)
    const depth = countNesting(text);
    if (depth > 6) {
        tips.push({
            type: 'readability',
            msg: `Expression has ${depth} levels of nesting. Consider using Format button or breaking into route conditions.`,
            severity: 'info'
        });
    }

    // 6. Detect null check patterns that could use Elvis operator or defaultTo()
    const nullCheckPattern = /(\w+(?:\.\w+)+)\s*!=\s*null\s*\?\s*\1/g;
    if (nullCheckPattern.test(text)) {
        tips.push({
            type: 'style',
            msg: `Pattern "x != null ? x : default" can be simplified with defaultTo(x, default) or coalesce().`,
            severity: 'info'
        });
    }

    // 7. Detect empty string comparisons that could use isEmpty()
    if (/==\s*["']{2}|["']{2}\s*==/.test(text)) {
        tips.push({
            type: 'style',
            msg: `Empty string comparison (== "") can be replaced with isEmpty() for clarity.`,
            severity: 'info'
        });
    }

    return tips;
}

function countNesting(text) {
    let maxDepth = 0, depth = 0;
    for (const ch of text) {
        if (ch === '(') { depth++; maxDepth = Math.max(maxDepth, depth); }
        else if (ch === ')') { depth--; }
    }
    return maxDepth;
}

// Global state for error/warning highlighting
let currentValidationState = { valid: true, errors: [], warnings: [] };

function validateSyntax(text) {
    const errorDiv = document.getElementById('syntax-error');
    if (!text || !text.trim()) {
        errorDiv.classList.remove('show');
        currentValidationState = { valid: true, errors: [], warnings: [] };
        updateHighlight();
        updateLineNumbers();
        return { valid: true };
    }

    try {
        new Parser(text).parse();

        // Check for semantic warnings (typos, invalid props)
        const warnings = checkSemantics(text);
        if (warnings.length > 0) {
            const w = warnings[0];
            const posInfo = `<span class="syntax-error-pos">(line ${w.line}, column ${w.col})</span>`;
            const gotoLink = `<span class="syntax-error-goto" onmousedown="event.preventDefault(); gotoPosition(${w.line}, ${w.col}, event)">Go to</span>`;
            errorDiv.innerHTML = `<span class="syntax-error-icon">⚠️</span>${escapeHtml(w.msg)}${posInfo}${gotoLink}`;
            errorDiv.classList.add('show');
            errorDiv.style.borderColor = '#f59e0b';
            errorDiv.style.background = 'rgba(245, 158, 11, 0.1)';
            currentValidationState = { valid: true, errors: [], warnings };
            updateHighlight();
            updateLineNumbers();
            return { valid: true, warnings };
        }

        errorDiv.classList.remove('show');
        currentValidationState = { valid: true, errors: [], warnings: [] };
        updateHighlight();
        updateLineNumbers();
        return { valid: true };
    } catch (e) {
        const msg = e.message;
        errorDiv.style.borderColor = '#ef4444';
        errorDiv.style.background = 'rgba(239, 68, 68, 0.1)';
        // Extract position info if available (e.g., "at 1:15")
        const posMatch = msg.match(/at (\d+):(\d+)/);
        let displayMsg = msg;
        let posInfo = '';
        let line = null, col = null;

        if (posMatch) {
            line = parseInt(posMatch[1]);
            col = parseInt(posMatch[2]);
            posInfo = `(line ${line}, column ${col})`;
            // Clean up the message
            displayMsg = msg.replace(/ at \d+:\d+$/, '');
        }

        const gotoLink = line ? `<span class="syntax-error-goto" onmousedown="event.preventDefault(); gotoPosition(${line}, ${col}, event)">Go to</span>` : '';
        errorDiv.innerHTML = `<span class="syntax-error-icon">❌</span>${escapeHtml(displayMsg)}${posInfo ? `<span class="syntax-error-pos">${posInfo}</span>` : ''}${gotoLink}`;
        errorDiv.classList.add('show');

        currentValidationState = {
            valid: false,
            errors: line ? [{ line, col, msg: displayMsg }] : [],
            warnings: []
        };
        updateHighlight();
        updateLineNumbers();
        return { valid: false, error: msg, line, column: col };
    }
}

// Flag to prevent blur validation when clicking "Go to"
let skipNextBlurValidation = false;

// Go to specific position in editor
function gotoPosition(line, col, event) {
    // Prevent default and stop propagation to avoid re-validation
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }

    // Skip the next blur validation
    skipNextBlurValidation = true;

    const textarea = document.getElementById('condition');
    const text = textarea.value;
    const lines = text.split('\n');

    // Calculate character position
    let pos = 0;
    for (let i = 0; i < line - 1 && i < lines.length; i++) {
        pos += lines[i].length + 1; // +1 for newline
    }
    pos += Math.min(col - 1, lines[line - 1]?.length || 0);

    // Focus and set cursor position
    textarea.focus();
    textarea.setSelectionRange(pos, pos);

    // Scroll to make cursor visible
    const lineHeight = parseInt(getComputedStyle(textarea).lineHeight) || 20;
    const scrollTop = (line - 3) * lineHeight; // Show a few lines before
    textarea.scrollTop = Math.max(0, scrollTop);

    // Reset flag after a short delay
    setTimeout(() => { skipNextBlurValidation = false; }, 100);
}

// ============== Request & Variables Preview ==============
function updateRequestPreview(request) {
    const card = document.getElementById('request-preview-card');
    const preview = document.getElementById('request-preview');
    card.style.display = 'block';

    // Build normalized headers
    const normalizedHeaders = {};
    for (const [k, v] of Object.entries(request.headers)) {
        normalizedHeaders[k.toLowerCase()] = Array.isArray(v) ? v : [v];
    }

    // Build rows: field name, variable path, value
    const rows = [
        { field: 'Method', varPath: 'request.method', value: request.method },
        { field: 'Host', varPath: 'request.uri.host', value: request.host },
        { field: 'Path', varPath: 'request.uri.path', value: request.path },
        { field: 'Query', varPath: 'request.uri.query', value: request.query },
    ];

    // Add headers
    for (const [name, values] of Object.entries(normalizedHeaders)) {
        rows.push({ field: name, varPath: `request.headers['${name}']`, value: values.join(', ') });
    }

    // Add cookies
    for (const [name, value] of Object.entries(request.cookies || {})) {
        rows.push({ field: `Cookie: ${name}`, varPath: `request.cookies['${name}']`, value: value });
    }

    // Add body
    if (request.body) {
        try {
            JSON.parse(request.body);
            rows.push({ field: 'Body (JSON)', varPath: 'request.entity.json', value: request.body.length > 100 ? request.body.substring(0, 97) + '...' : request.body });
        } catch {
            rows.push({ field: 'Body', varPath: 'request.entity.string', value: request.body.length > 100 ? request.body.substring(0, 97) + '...' : request.body });
        }
    }

    let html = rows.map(r => `
        <div class="preview-row">
            <span class="preview-field">${escapeHtml(r.field)}</span>
            <span class="preview-var">${r.varPath}</span>
            <span class="preview-value ${r.value ? '' : 'empty'}">${r.value ? escapeHtml(r.value) : '(empty)'}</span>
        </div>
    `).join('');

    preview.innerHTML = html;
}

// ============== History ==============
const HISTORY_KEY = 'ig-validator-history';
const MAX_HISTORY = 20;

function getHistory() {
    try {
        return JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];
    } catch { return []; }
}

function saveHistory(condition, curl) {
    const history = getHistory();
    const entry = {
        time: Date.now(),
        condition: condition,
        curl: curl
    };
    // Remove duplicate
    const idx = history.findIndex(h => h.condition === condition && h.curl === curl);
    if (idx !== -1) history.splice(idx, 1);
    history.unshift(entry);
    if (history.length > MAX_HISTORY) history.pop();
    localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
}

function renderHistory() {
    const dropdown = document.getElementById('history-dropdown');
    const history = getHistory();

    if (history.length === 0) {
        dropdown.innerHTML = '<div class="history-empty">No history yet</div>';
        return;
    }

    let html = history.map((h, idx) => {
        const time = new Date(h.time).toLocaleString();
        const condShort = h.condition.length > 60 ? h.condition.substring(0, 57) + '...' : h.condition;
        const curlShort = h.curl ? (h.curl.length > 40 ? h.curl.substring(0, 37) + '...' : h.curl) : '(no request)';
        return `
            <div class="history-item" data-idx="${idx}">
                <button class="history-delete" data-delete-idx="${idx}" title="Delete">×</button>
                <div class="history-time">${time}</div>
                <div class="history-condition">${escapeHtml(condShort)}</div>
                <div class="history-request">${escapeHtml(curlShort)}</div>
            </div>
        `;
    }).join('');

    html += `<div class="history-clear"><button class="history-clear-btn" id="clear-history">Clear History</button></div>`;
    dropdown.innerHTML = html;
}

document.getElementById('history-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    const btn = e.currentTarget;
    const dropdown = document.getElementById('history-dropdown');
    dropdown.classList.toggle('show');
    if (dropdown.classList.contains('show')) {
        // Position dropdown below button using fixed positioning
        const rect = btn.getBoundingClientRect();
        dropdown.style.top = (rect.bottom + 4) + 'px';
        dropdown.style.left = rect.left + 'px';
        renderHistory();
    }
});

document.getElementById('history-dropdown').addEventListener('click', (e) => {
    // Handle single item delete
    if (e.target.classList.contains('history-delete')) {
        e.stopPropagation();
        const idx = parseInt(e.target.dataset.deleteIdx);
        const history = getHistory();
        history.splice(idx, 1);
        localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
        renderHistory();
        return;
    }

    // Handle item click to load
    const item = e.target.closest('.history-item');
    if (item) {
        const idx = parseInt(item.dataset.idx);
        const history = getHistory();
        if (history[idx]) {
            document.getElementById('condition').value = history[idx].condition;
            document.getElementById('curl-input').value = history[idx].curl || '';
            updateHighlight();
            updateLineNumbers();
            validateSyntax(history[idx].condition);
            document.getElementById('history-dropdown').classList.remove('show');
        }
    }

    // Handle clear all
    if (e.target.id === 'clear-history') {
        localStorage.removeItem(HISTORY_KEY);
        renderHistory();
    }
});

// Close dropdown when clicking outside
document.addEventListener('click', () => {
    document.getElementById('history-dropdown').classList.remove('show');
});

// Toggle preview panel
document.getElementById('preview-toggle')?.addEventListener('click', () => {
    document.getElementById('request-preview').classList.toggle('collapsed');
    const btn = document.getElementById('preview-toggle');
    btn.textContent = btn.textContent === '▼' ? '▶' : '▼';
});

document.getElementById('diagnose-btn').addEventListener('click', () => {
    const condition = document.getElementById('condition').value;
    if (!condition) { alert('Please enter a condition'); return; }

    // Validate syntax first
    const validation = validateSyntax(condition);
    if (!validation.valid) {
        return; // Don't proceed if syntax error
    }

    // Parse cURL if there's content
    const curl = document.getElementById('curl-input').value;
    if (curl) {
        currentRequest = parseCurl(curl);
    }

    // Update preview
    updateRequestPreview(currentRequest);

    // Save to history
    saveHistory(condition, curl);

    const result = diagnose(condition, currentRequest);
    displayResult(result);
});

function displayResult(result) {
    const container = document.getElementById('result-container');
    container.textContent = '';

    if (!result.success) {
        container.appendChild(createHeader('error', '⚠️', 'Error', result.error));
        return;
    }

    const type = result.overall ? 'passed' : 'failed';
    const icon = result.overall ? '✓' : '✗';
    const status = result.overall ? 'PASSED' : 'FAILED';
    container.appendChild(createHeader(type, icon, status, result.summary));

    if (result.conditions.length > 0) {
        const list = document.createElement('div');
        list.className = 'condition-list';
        result.conditions.forEach((c, idx) => list.appendChild(createConditionItem(c, idx + 1, result.conditions.length)));
        container.appendChild(list);
    }

    // Add performance tips section
    if (result.performanceTips && result.performanceTips.length > 0) {
        container.appendChild(createPerformanceTips(result.performanceTips));
    }
}

// Create performance tips display
function createPerformanceTips(tips) {
    const wrapper = document.createElement('div');
    wrapper.style.marginTop = '0.75rem';

    const warningCount = tips.filter(t => t.severity === 'warning').length;
    const infoCount = tips.filter(t => t.severity === 'info').length;

    const header = document.createElement('div');
    header.className = 'collapsible';
    header.innerHTML = `<strong style="color:#fbbf24">💡 Performance Tips</strong> <span style="color:#64748b;font-size:0.8rem">(${warningCount} warning${warningCount !== 1 ? 's' : ''}, ${infoCount} suggestion${infoCount !== 1 ? 's' : ''})</span>`;

    const content = document.createElement('div');
    content.className = 'collapse-content';
    content.style.cssText = 'margin-top:0.5rem;';

    const tipsDiv = document.createElement('div');
    tipsDiv.className = 'performance-tips';

    tips.forEach(tip => {
        const tipDiv = document.createElement('div');
        tipDiv.className = 'performance-tip ' + tip.severity;

        const icon = tip.severity === 'warning' ? '⚠️' : '💡';
        const typeLabel = tip.type.charAt(0).toUpperCase() + tip.type.slice(1);

        tipDiv.innerHTML = `<span class="tip-icon">${icon}</span><span class="tip-type">[${typeLabel}]</span> ${escapeHtml(tip.msg)}`;
        tipsDiv.appendChild(tipDiv);
    });

    content.appendChild(tipsDiv);

    header.addEventListener('click', () => {
        header.classList.toggle('expanded');
        content.classList.toggle('show');
    });

    wrapper.appendChild(header);
    wrapper.appendChild(content);
    return wrapper;
}

function createHeader(type, icon, title, msg) {
    const div = document.createElement('div');
    div.className = 'result-header result-' + type;

    const iconSpan = document.createElement('span');
    iconSpan.className = 'result-icon';
    iconSpan.textContent = icon;

    const content = document.createElement('div');
    const titleEl = document.createElement('strong');
    titleEl.textContent = title;
    const msgEl = document.createElement('div');
    msgEl.style.cssText = 'font-size:0.9rem;margin-top:0.25rem';
    msgEl.textContent = msg;

    content.appendChild(titleEl);
    content.appendChild(msgEl);
    div.appendChild(iconSpan);
    div.appendChild(content);
    return div;
}

// Helper to create a collapsible section
function createCollapsible(headerContent, detailsContent, startExpanded = false) {
    const wrapper = document.createElement('div');

    const header = document.createElement('div');
    header.className = 'collapsible' + (startExpanded ? ' expanded' : '');
    if (typeof headerContent === 'string') {
        header.innerHTML = headerContent;
    } else {
        header.appendChild(headerContent);
    }

    const content = document.createElement('div');
    content.className = 'collapse-content' + (startExpanded ? ' show' : '');
    if (typeof detailsContent === 'string') {
        content.innerHTML = detailsContent;
    } else {
        content.appendChild(detailsContent);
    }

    header.addEventListener('click', () => {
        header.classList.toggle('expanded');
        content.classList.toggle('show');
    });

    wrapper.appendChild(header);
    wrapper.appendChild(content);
    return wrapper;
}

// Extract short description from expression (e.g., get the pattern from matches())
function getShortDesc(expr, asHtml = false) {
    // For matches/contains, extract the function name and pattern
    const matchResult = expr.match(/(?:(matches|matchesWithRegex|contains|find|findGroups|startsWith|endsWith))\s*\([^,]+,\s*['"]([^'"]+)['"]\)/);
    if (matchResult) {
        const fnName = matchResult[1];
        const pattern = matchResult[2];
        const truncatedPattern = pattern.length > 50 ? pattern.slice(0, 47) + '...' : pattern;
        if (asHtml) {
            return `<span class="fn-name">${escapeHtml(fnName)}</span>(<span class="pattern-highlight">${escapeHtml(truncatedPattern)}</span>)`;
        }
        return truncatedPattern;
    }
    // For other expressions, truncate
    const truncated = expr.length > 60 ? expr.slice(0, 57) + '...' : expr;
    return asHtml ? escapeHtml(truncated) : truncated;
}

function createConditionItem(c, index, total) {
    const div = document.createElement('div');
    div.className = 'condition-item ' + (c.passed ? 'passed' : 'failed');

    const statusIcon = c.passed ? '✓' : '✗';
    const statusColor = c.passed ? '#10b981' : '#ef4444';

    // Show index if there are multiple conditions at root level
    const indexLabel = (total && total > 1) ? `<strong style="color:#94a3b8">${index}.</strong> ` : '';

    if (c.isOrGroup) {
        // OR Group - show summary
        const passedCount = c.branches.filter(b => b.passed).length;
        const totalCount = c.branches.length;

        // Find which branch passed (if any)
        const passedBranch = c.branches.find(b => b.passed);
        let summaryText = `${passedCount}/${totalCount} branches match`;
        let matchedPatternsHtml = '';
        if (passedBranch && passedBranch.subDetails && passedBranch.subDetails.length > 0) {
            // Show what matched with highlighting
            const matchedPatternsArr = passedBranch.subDetails
                .filter(s => s.passed)
                .map(s => getShortDesc(s.expression, true))
                .slice(0, 2);
            if (matchedPatternsArr.length > 0) {
                matchedPatternsHtml = ` — matched: ${matchedPatternsArr.join(', ')}`;
            }
        }

        const headerHtml = `${indexLabel}<span style="color:${statusColor}">${statusIcon}</span> <strong>OR</strong> <span style="color:#94a3b8;font-size:0.85rem">${summaryText}</span>${matchedPatternsHtml}`;

        // Details: list each branch simply
        const detailsDiv = document.createElement('div');
        detailsDiv.style.cssText = 'padding-left: 1rem; margin-top: 0.5rem;';

        c.branches.forEach((branch, idx) => {
            const branchItem = createBranchItem(branch, idx + 1);
            detailsDiv.appendChild(branchItem);
        });

        const collapsible = createCollapsible(headerHtml, detailsDiv, c.passed);
        div.appendChild(collapsible);

    } else {
        // Single condition
        const shortExprHtml = getShortDesc(c.expression, true);
        const hasDetails = c.details || (c.suggestion && !c.passed);

        if (hasDetails) {
            const headerHtml = `${indexLabel}<span style="color:${statusColor}">${statusIcon}</span> <code style="font-size:0.85rem;color:#e2e8f0">${shortExprHtml}</code> → <span class="${c.passed ? 'val-true' : 'val-false'}">${c.passed}</span>`;

            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'condition-details';
            detailsDiv.style.cssText = 'padding-left: 1.5rem; margin-top: 0.5rem;';

            if (c.details) {
                const det = document.createElement('div');
                det.innerHTML = c.details;
                detailsDiv.appendChild(det);
            }

            if (c.suggestion && !c.passed) {
                const sug = document.createElement('div');
                sug.className = 'condition-suggestion';
                sug.innerHTML = '💡 ' + c.suggestion;
                detailsDiv.appendChild(sug);
            }

            const collapsible = createCollapsible(headerHtml, detailsDiv, c.passed);
            div.appendChild(collapsible);
        } else {
            const expr = document.createElement('div');
            expr.className = 'condition-expr';
            expr.innerHTML = `${indexLabel}<span style="color:${statusColor}">${statusIcon}</span> <code style="font-size:0.85rem">${shortExprHtml}</code> → <span class="${c.passed ? 'val-true' : 'val-false'}">${c.passed}</span>`;
            div.appendChild(expr);
        }
    }

    return div;
}

// Create a branch item (for OR group branches)
function createBranchItem(branch, index) {
    const branchDiv = document.createElement('div');
    branchDiv.style.cssText = 'margin: 0.25rem 0; padding: 0.5rem; background: #1e293b; border-radius: 4px;';

    const statusIcon = branch.passed ? '✓' : '○';
    const statusColor = branch.passed ? '#10b981' : '#64748b';

    // Determine branch type and create concise summary
    let branchSummary;
    if (branch.subDetails && branch.subDetails.length > 0) {
        // AND condition with multiple parts
        const passedSubs = branch.subDetails.filter(s => s.passed);
        const patterns = branch.subDetails.map(s => ({
            patternHtml: getShortDesc(s.expression, true),
            passed: s.passed
        }));

        // Show patterns with their status
        branchSummary = patterns.map(p =>
            `<span style="color:${p.passed ? '#10b981' : '#64748b'}">${p.passed ? '✓' : '✗'}</span> ${p.patternHtml}`
        ).join('<br>');
    } else {
        branchSummary = `<code style="font-size:0.8rem">${getShortDesc(branch.expression, true)}</code>`;
    }

    const hasDetails = (branch.subDetails && branch.subDetails.length > 0);

    if (hasDetails) {
        // Count passed sub-conditions
        const passedCount = branch.subDetails.filter(s => s.passed).length;
        const totalCount = branch.subDetails.length;

        // Show relationship summary like "AND 2/2 conditions"
        let headerHtml;
        if (totalCount > 1) {
            headerHtml = `<span style="color:${statusColor}">${statusIcon}</span> <strong style="color:#94a3b8">Branch ${index}</strong> <strong class="op">AND</strong> <span style="color:#94a3b8;font-size:0.85rem">${passedCount}/${totalCount} conditions match</span> → <span class="${branch.passed ? 'val-true' : 'val-false'}">${branch.passed}</span>`;
        } else {
            headerHtml = `<span style="color:${statusColor}">${statusIcon}</span> <strong style="color:#94a3b8">Branch ${index}</strong> → <span class="${branch.passed ? 'val-true' : 'val-false'}">${branch.passed}</span>`;
        }

        const detailsDiv = document.createElement('div');
        detailsDiv.style.cssText = 'padding-left: 1rem; margin-top: 0.5rem;';

        // Show each sub-condition
        branch.subDetails.forEach((sub, idx) => {
            const subItem = createSubDetailItem(sub);
            detailsDiv.appendChild(subItem);
        });

        const collapsible = createCollapsible(headerHtml, detailsDiv, branch.passed);
        branchDiv.appendChild(collapsible);
    } else {
        branchDiv.innerHTML = `<span style="color:${statusColor}">${statusIcon}</span> <code style="font-size:0.8rem;color:#e2e8f0">${getShortDesc(branch.expression, true)}</code> → <span class="${branch.passed ? 'val-true' : 'val-false'}">${branch.passed}</span>`;
    }

    return branchDiv;
}

// Create a sub-detail item (for individual function calls)
function createSubDetailItem(sub) {
    const subDiv = document.createElement('div');
    subDiv.style.cssText = 'margin: 0.25rem 0;';

    const statusIcon = sub.passed ? '✓' : '○';
    const statusColor = sub.passed ? '#10b981' : '#64748b';
    const patternHtml = getShortDesc(sub.expression, true);

    if (sub.details) {
        const headerHtml = `<span style="color:${statusColor}">${statusIcon}</span> <code style="font-size:0.8rem;color:#e2e8f0">${patternHtml}</code> → <span class="${sub.passed ? 'val-true' : 'val-false'}">${sub.passed}</span>`;

        const detailsDiv = document.createElement('div');
        detailsDiv.className = 'condition-details';
        detailsDiv.style.cssText = 'padding-left: 1.5rem; font-size: 0.8rem; margin-top: 0.25rem;';
        detailsDiv.innerHTML = sub.details;

        const collapsible = createCollapsible(headerHtml, detailsDiv, sub.passed);
        subDiv.appendChild(collapsible);
    } else {
        subDiv.innerHTML = `<span style="color:${statusColor}">${statusIcon}</span> <code style="font-size:0.8rem;color:#e2e8f0">${patternHtml}</code> → <span class="${sub.passed ? 'val-true' : 'val-false'}">${sub.passed}</span>`;
    }

    return subDiv;
}

// Helper to escape HTML
function escapeHtml(str) {
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

// ============== Syntax Highlighting ==============
const HIGHLIGHT_KEYWORDS = new Set(['and', 'or', 'not', 'true', 'false', 'null', 'empty', 'eq', 'ne', 'lt', 'le', 'gt', 'ge', 'div', 'mod']);
const HIGHLIGHT_FUNCTIONS = new Set([
    // Official IG functions (org.forgerock.openig.el.Functions)
    'array', 'boolean', 'contains', 'decodeBase64', 'decodeBase64url',
    'digestSha256', 'encodeBase64', 'encodeBase64url',
    'find', 'findGroups', 'indexOf', 'integer', 'integerWithRadix',
    'ipMatch', 'join', 'keyMatch', 'length', 'matches', 'matchingGroups',
    'split', 'toJson', 'toLowerCase', 'toString', 'toUpperCase', 'trim',
    // Official IG functions (org.forgerock.http.util.Uris)
    'urlDecode', 'urlEncode', 'urlDecodeFragment', 'urlDecodePathElement',
    'urlDecodeQueryParameterNameOrValue', 'urlDecodeUserInfo',
    'urlEncodeFragment', 'urlEncodePathElement',
    'urlEncodeQueryParameterNameOrValue', 'urlEncodeUserInfo',
    'formDecodeParameterNameOrValue', 'formEncodeParameterNameOrValue',
    // Additional common functions (supported in expressions)
    'startsWith', 'endsWith', 'substring', 'replace', 'replaceAll',
    'first', 'last', 'slice', 'keys', 'values', 'entries',
    'empty', 'isEmpty', 'isNull', 'isNotNull', 'defaultTo', 'coalesce',
    'abs', 'ceil', 'floor', 'round', 'min', 'max',
    'now', 'timestamp', 'jsonParse', 'jsonStringify',
]);

function highlightExpression(text) {
    if (!text) return '';

    let result = '';
    let i = 0;

    while (i < text.length) {
        // Check for expression delimiters ${...} or #{...}
        if ((text[i] === '$' || text[i] === '#') && text[i + 1] === '{') {
            result += `<span class="tok-delimiter">${escapeHtml(text.slice(i, i + 2))}</span>`;
            i += 2;
            continue;
        }

        // Check for closing brace
        if (text[i] === '}') {
            result += `<span class="tok-delimiter">}</span>`;
            i++;
            continue;
        }

        // Check for strings
        if (text[i] === '"' || text[i] === "'") {
            const quote = text[i];
            let str = quote;
            i++;
            while (i < text.length && text[i] !== quote) {
                if (text[i] === '\\' && i + 1 < text.length) {
                    str += text[i] + text[i + 1];
                    i += 2;
                } else {
                    str += text[i];
                    i++;
                }
            }
            if (i < text.length) {
                str += text[i];
                i++;
            }
            result += `<span class="tok-string">${escapeHtml(str)}</span>`;
            continue;
        }

        // Check for numbers
        if (/\d/.test(text[i])) {
            let num = '';
            while (i < text.length && /[\d.]/.test(text[i])) {
                num += text[i];
                i++;
            }
            result += `<span class="tok-number">${escapeHtml(num)}</span>`;
            continue;
        }

        // Check for identifiers/keywords
        if (/[a-zA-Z_]/.test(text[i])) {
            let ident = '';
            while (i < text.length && /[a-zA-Z0-9_]/.test(text[i])) {
                ident += text[i];
                i++;
            }

            // Look ahead for function call
            let j = i;
            while (j < text.length && /\s/.test(text[j])) j++;
            const isFunc = j < text.length && text[j] === '(';

            if (HIGHLIGHT_KEYWORDS.has(ident.toLowerCase())) {
                result += `<span class="tok-keyword">${escapeHtml(ident)}</span>`;
            } else if (HIGHLIGHT_FUNCTIONS.has(ident) || isFunc) {
                result += `<span class="tok-function">${escapeHtml(ident)}</span>`;
            } else {
                result += `<span class="tok-property">${escapeHtml(ident)}</span>`;
            }
            continue;
        }

        // Check for operators
        if ('!=<>'.includes(text[i])) {
            let op = text[i];
            if (i + 1 < text.length && '='.includes(text[i + 1])) {
                op += text[i + 1];
                i++;
            }
            result += `<span class="tok-operator">${escapeHtml(op)}</span>`;
            i++;
            continue;
        }

        // Brackets
        if ('()[]'.includes(text[i])) {
            result += `<span class="tok-bracket">${escapeHtml(text[i])}</span>`;
            i++;
            continue;
        }

        // Dot and comma
        if (text[i] === '.' || text[i] === ',') {
            result += `<span class="tok-delimiter">${escapeHtml(text[i])}</span>`;
            i++;
            continue;
        }

        // Whitespace and other
        result += escapeHtml(text[i]);
        i++;
    }

    return result;
}

function escapeHtml(text) {
    return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function updateHighlight() {
    const textarea = document.getElementById('condition');
    const backdrop = document.getElementById('condition-highlight');
    const text = textarea.value;
    let html = highlightExpression(text);

    // Apply error/warning highlights
    if (currentValidationState) {
        const lines = text.split('\n');

        // Highlight errors (red background)
        currentValidationState.errors.forEach(err => {
            if (err.line && err.col) {
                html = addPositionHighlight(html, text, err.line, err.col, 'error-highlight');
            }
        });

        // Highlight warnings (orange background)
        currentValidationState.warnings.forEach(w => {
            if (w.line && w.col && w.word) {
                html = addPositionHighlight(html, text, w.line, w.col, 'warning-highlight', w.word.length);
            }
        });
    }

    backdrop.innerHTML = html + '\n'; // extra newline to match textarea
}

// Add highlight at specific position
function addPositionHighlight(html, text, line, col, className, length = 1) {
    const lines = text.split('\n');
    if (line > lines.length) return html;

    // Find the character position in the text
    let charPos = 0;
    for (let i = 0; i < line - 1; i++) {
        charPos += lines[i].length + 1;
    }
    charPos += col - 1;

    // We need to find the corresponding position in the HTML
    // This is complex due to HTML entities and tags, so we'll use a simpler approach:
    // Re-highlight the specific line with the error marker
    const htmlLines = html.split('\n');
    if (line <= htmlLines.length) {
        const lineText = lines[line - 1];
        const beforeError = lineText.substring(0, col - 1);
        const errorText = lineText.substring(col - 1, col - 1 + length);

        if (errorText) {
            // Re-highlight the line with the error span
            const highlightedLine = highlightExpression('${' + lineText + '}')
                .replace(/^\$\{/, '').replace(/\}$/, '');

            // Try to inject the error highlight
            // Find the position after escaping
            const escapedBefore = escapeHtml(beforeError);
            const escapedError = escapeHtml(errorText);

            // Simple approach: wrap the entire line with error indicator
            htmlLines[line - 1] = htmlLines[line - 1].replace(
                new RegExp(escapeRegExp(escapedError)),
                `<span class="${className}">${escapedError}</span>`
            );
        }
    }
    return htmlLines.join('\n');
}

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// ============== Format Expression ==============
function formatExpression(text) {
    // Extract content from ${...} or #{...}
    const match = text.match(/^(\$\{|\#\{)([\s\S]*)\}$/);
    if (!match) return text;

    const prefix = match[1];
    const inner = match[2].trim();

    // Parse into AST-like structure and format
    try {
        const formatted = formatExpr(inner, 1);
        return prefix + '\n' + formatted + '\n}';
    } catch (e) {
        // If parsing fails, return original
        return text;
    }
}

function tokenizeForFormat(expr) {
    const tokens = [];
    let i = 0;

    while (i < expr.length) {
        // Skip whitespace
        if (/\s/.test(expr[i])) {
            i++;
            continue;
        }

        // String
        if (expr[i] === '"' || expr[i] === "'") {
            const quote = expr[i];
            let str = quote;
            i++;
            while (i < expr.length && expr[i] !== quote) {
                if (expr[i] === '\\') { str += expr[i++]; }
                if (i < expr.length) { str += expr[i++]; }
            }
            if (i < expr.length) { str += expr[i++]; }
            tokens.push({ type: 'string', value: str });
            continue;
        }

        // Identifier or keyword
        if (/[a-zA-Z_]/.test(expr[i])) {
            let ident = '';
            while (i < expr.length && /[a-zA-Z0-9_]/.test(expr[i])) {
                ident += expr[i++];
            }
            const lower = ident.toLowerCase();
            if (lower === 'and' || lower === 'or' || lower === 'not') {
                tokens.push({ type: 'keyword', value: lower });
            } else {
                tokens.push({ type: 'ident', value: ident });
            }
            continue;
        }

        // Numbers
        if (/\d/.test(expr[i])) {
            let num = '';
            while (i < expr.length && /[\d.]/.test(expr[i])) {
                num += expr[i++];
            }
            tokens.push({ type: 'number', value: num });
            continue;
        }

        // Two-char operators
        if (i + 1 < expr.length) {
            const two = expr[i] + expr[i + 1];
            if (['==', '!=', '<=', '>=', '&&', '||'].includes(two)) {
                tokens.push({ type: 'op', value: two });
                i += 2;
                continue;
            }
        }

        // Single-char operators that need spacing
        if (['>', '<', '+', '-', '*', '/', '%', '?', ':'].includes(expr[i])) {
            tokens.push({ type: 'op', value: expr[i] });
            i++;
            continue;
        }

        // Single char (parens, brackets, comma, dot, etc)
        tokens.push({ type: 'char', value: expr[i] });
        i++;
    }

    return tokens;
}

function formatExpr(expr, baseIndent) {
    const tokens = tokenizeForFormat(expr);

    // If the entire expression is wrapped in parens, strip them and recurse
    if (tokens.length > 0 && tokens[0].value === '(') {
        let depth = 0;
        let closeIdx = -1;
        for (let i = 0; i < tokens.length; i++) {
            if (tokens[i].value === '(') depth++;
            else if (tokens[i].value === ')') {
                depth--;
                if (depth === 0) { closeIdx = i; break; }
            }
        }
        if (closeIdx === tokens.length - 1) {
            // Entire expression is wrapped - format inner content
            const inner = tokens.slice(1, closeIdx);
            const innerStr = tokensToString(inner);
            const innerFormatted = formatExpr(innerStr.trim(), baseIndent);
            // Check if inner was formatted with newlines
            if (innerFormatted.includes('\n')) {
                return '  '.repeat(baseIndent) + '(' + innerFormatted.trim() + ')';
            }
            // Keep it wrapped
            return '  '.repeat(baseIndent) + '(' + innerFormatted.trim() + ')';
        }
    }

    // Find top-level OR splits (these are major branches)
    const orBranches = splitByTopLevelOp(tokens, 'or');

    // Split OR if there are 2 or more branches
    if (orBranches.length > 1) {
        // Multiple OR branches - format each on its own line
        const indent = '  '.repeat(baseIndent);
        const formatted = orBranches.map((branch, i) => {
            const branchStr = formatBranch(branch, baseIndent);
            return indent + branchStr;
        });
        return formatted.join('\nor\n');
    }

    // Single branch or simple "a or b" - check for AND
    const andBranches = splitByTopLevelOp(tokens, 'and');

    if (andBranches.length > 1) {
        const indent = '  '.repeat(baseIndent);
        const formatted = andBranches.map((branch, i) => {
            const branchStr = formatBranch(branch, baseIndent);
            return branchStr;
        });
        return indent + formatted.join(' and ');
    }

    // No top-level operators, return as-is
    return '  '.repeat(baseIndent) + tokensToString(tokens);
}

function splitByTopLevelOp(tokens, op) {
    const branches = [];
    let current = [];
    let depth = 0;

    for (const tok of tokens) {
        if (tok.value === '(' || tok.value === '[') {
            depth++;
            current.push(tok);
        } else if (tok.value === ')' || tok.value === ']') {
            depth--;
            current.push(tok);
        } else if (depth === 0 && tok.type === 'keyword' && tok.value === op) {
            if (current.length > 0) {
                branches.push(current);
            }
            current = [];
        } else {
            current.push(tok);
        }
    }

    if (current.length > 0) {
        branches.push(current);
    }

    return branches;
}

function formatBranch(tokens, baseIndent) {
    // Check if this is a parenthesized group
    if (tokens.length > 0 && tokens[0].value === '(') {
        // Find matching close paren
        let depth = 0;
        let closeIdx = -1;
        for (let i = 0; i < tokens.length; i++) {
            if (tokens[i].value === '(') depth++;
            else if (tokens[i].value === ')') {
                depth--;
                if (depth === 0) { closeIdx = i; break; }
            }
        }

        if (closeIdx === tokens.length - 1) {
            // Entire branch is wrapped in parens
            const inner = tokens.slice(1, closeIdx);

            // First check if inner is double-wrapped (((...)))
            if (inner.length > 0 && inner[0].value === '(') {
                let innerDepth = 0;
                let innerClose = -1;
                for (let i = 0; i < inner.length; i++) {
                    if (inner[i].value === '(') innerDepth++;
                    else if (inner[i].value === ')') {
                        innerDepth--;
                        if (innerDepth === 0) { innerClose = i; break; }
                    }
                }
                if (innerClose === inner.length - 1) {
                    // It's ((content)) - recurse into inner with increased indent
                    const innerFormatted = formatBranch(inner, baseIndent + 1);
                    if (innerFormatted.includes('\n')) {
                        return '(\n  ' + '  '.repeat(baseIndent) + innerFormatted + '\n' + '  '.repeat(baseIndent) + ')';
                    }
                }
            }

            // Check for AND + OR pattern: (A and B or C or D...) or (A and (B or C or D...))
            // Find the first top-level 'and'
            const innerAnds = splitByTopLevelOp(inner, 'and');
            if (innerAnds.length >= 2) {
                // Combine everything after first 'and' and check for 'or' chain
                const afterAnd = [];
                for (let i = 1; i < innerAnds.length; i++) {
                    if (i > 1) afterAnd.push({ type: 'keyword', value: 'and' });
                    afterAnd.push(...innerAnds[i]);
                }

                // Check if afterAnd is a parenthesized OR chain: (B or C or D...)
                if (afterAnd.length > 0 && afterAnd[0].value === '(') {
                    let parenDepth = 0;
                    let parenClose = -1;
                    for (let i = 0; i < afterAnd.length; i++) {
                        if (afterAnd[i].value === '(') parenDepth++;
                        else if (afterAnd[i].value === ')') {
                            parenDepth--;
                            if (parenDepth === 0) { parenClose = i; break; }
                        }
                    }
                    if (parenClose === afterAnd.length - 1) {
                        // afterAnd is entirely wrapped in parens
                        const insideParen = afterAnd.slice(1, parenClose);
                        const orParts = splitByTopLevelOp(insideParen, 'or');
                        if (orParts.length > 1) {
                            // Pattern: (condition and (or_item1 or or_item2 or ...))
                            const condPart = tokensToString(innerAnds[0]);
                            const indent = '  '.repeat(baseIndent + 1);
                            const innerIndent = '  '.repeat(baseIndent + 2);
                            const lines = orParts.map(branch => innerIndent + tokensToString(branch));
                            return '(' + condPart + ' and (\n' + lines.join(' or\n') + '\n' + indent + '))';
                        }
                    }
                }

                const orParts = splitByTopLevelOp(afterAnd, 'or');
                if (orParts.length > 1) {
                    // Pattern: (condition and first_or_item or second_or_item or ...)
                    const condPart = tokensToString(innerAnds[0]);
                    const indent = '  '.repeat(baseIndent + 1);
                    const innerIndent = '  '.repeat(baseIndent + 2);
                    const lines = orParts.map(branch => innerIndent + tokensToString(branch));
                    return '(' + condPart + ' and (\n' + lines.join(' or\n') + '\n' + indent + '))';
                }
            }

            // Check if inner has OR chains (the common case for long lists)
            const innerOrs = splitByTopLevelOp(inner, 'or');
            if (innerOrs.length > 1) {
                // Many OR branches inside - format as block
                const indent = '  '.repeat(baseIndent + 1);
                const lines = innerOrs.map(branch => indent + tokensToString(branch));
                return '(\n' + lines.join(' or\n') + '\n' + '  '.repeat(baseIndent) + ')';
            }
        }
    }

    return tokensToString(tokens);
}

function tokensToString(tokens) {
    let result = '';
    let prevTok = null;

    for (const tok of tokens) {
        // Determine if we need a space before this token
        let needSpace = false;

        if (prevTok) {
            // Space before keywords (and, or, not) unless after (
            if (tok.type === 'keyword') {
                needSpace = prevTok.value !== '(';
            }
            // Space after keywords unless before )
            else if (prevTok.type === 'keyword') {
                needSpace = tok.value !== ')';
            }
            // Space between identifiers/numbers/strings
            else if ((prevTok.type === 'ident' || prevTok.type === 'number' || prevTok.type === 'string') &&
                     (tok.type === 'ident' || tok.type === 'number' || tok.type === 'string')) {
                needSpace = true;
            }
            // Space after ) if followed by ( or ident
            else if (prevTok.value === ')' && (tok.value === '(' || tok.type === 'ident')) {
                needSpace = true;
            }
            // Space around operators like ==, !=, etc
            else if (tok.type === 'op') {
                needSpace = prevTok.value !== '(';
            }
            else if (prevTok.type === 'op') {
                needSpace = tok.value !== ')';
            }
        }

        if (needSpace && result.length > 0 && !result.endsWith(' ')) {
            result += ' ';
        }

        result += tok.value;
        prevTok = tok;
    }

    return result.trim();
}

// ============== Editor Event Bindings ==============
const conditionTextarea = document.getElementById('condition');
const conditionHighlight = document.getElementById('condition-highlight');
const lineNumbers = document.getElementById('line-numbers');

// Update line numbers with error/warning highlighting
function updateLineNumbers() {
    const text = conditionTextarea.value;
    const lineCount = text.split('\n').length;
    const numbers = [];

    // Get error and warning lines
    const errorLines = new Set((currentValidationState?.errors || []).map(e => e.line));
    const warningLines = new Set((currentValidationState?.warnings || []).map(w => w.line));

    for (let i = 1; i <= Math.max(lineCount, 1); i++) {
        if (errorLines.has(i)) {
            numbers.push(`<span class="error-line">${i}</span>`);
        } else if (warningLines.has(i)) {
            numbers.push(`<span class="warning-line">${i}</span>`);
        } else {
            numbers.push(i);
        }
    }
    lineNumbers.innerHTML = numbers.join('<br>');
}

// Debounce helper for real-time validation
let validateTimeout = null;
function debouncedValidate() {
    clearTimeout(validateTimeout);
    validateTimeout = setTimeout(() => {
        validateSyntax(conditionTextarea.value);
    }, 500); // Wait 500ms after typing stops
}

conditionTextarea.addEventListener('input', () => {
    updateHighlight();
    updateLineNumbers();
    debouncedValidate();
});

conditionTextarea.addEventListener('scroll', () => {
    conditionHighlight.scrollTop = conditionTextarea.scrollTop;
    conditionHighlight.scrollLeft = conditionTextarea.scrollLeft;
    lineNumbers.scrollTop = conditionTextarea.scrollTop;
});

// Validate immediately on paste
conditionTextarea.addEventListener('paste', (e) => {
    // Use setTimeout to get the value after paste is applied
    setTimeout(() => {
        updateHighlight();
        updateLineNumbers();
        validateSyntax(conditionTextarea.value);
    }, 0);
});

// Also validate on blur (when user leaves the field)
conditionTextarea.addEventListener('blur', () => {
    if (skipNextBlurValidation) {
        skipNextBlurValidation = false;
        return;
    }
    clearTimeout(validateTimeout); // Clear pending debounce
    validateSyntax(conditionTextarea.value);
});

document.getElementById('format-btn').addEventListener('click', () => {
    const textarea = document.getElementById('condition');
    const text = textarea.value.trim();
    if (text) {
        // Validate first
        const validation = validateSyntax(text);
        if (!validation.valid) {
            return; // Don't format if invalid
        }
        const formatted = formatExpression(text);
        textarea.value = formatted;
        // Force sync scroll position
        const backdrop = document.getElementById('condition-highlight');
        backdrop.scrollTop = 0;
        textarea.scrollTop = 0;
        lineNumbers.scrollTop = 0;
        updateHighlight();
        updateLineNumbers();
    }
});

// Initial highlight and line numbers
updateHighlight();
updateLineNumbers();

// Sync line numbers height when textarea is resized
const resizeObserver = new ResizeObserver(() => {
    lineNumbers.style.height = conditionTextarea.offsetHeight + 'px';
});
resizeObserver.observe(conditionTextarea);

// ============== Resizable Grid ==============
(function() {
    const GRID_RATIO_KEY = 'ig-validator-grid-ratio';
    const grid = document.getElementById('main-grid');
    const resizer = document.getElementById('grid-resizer');
    let isResizing = false;
    let startX, startLeftWidth;

    // Restore saved ratio
    const savedRatio = localStorage.getItem(GRID_RATIO_KEY);
    if (savedRatio) {
        const leftFr = parseFloat(savedRatio);
        if (leftFr > 0 && leftFr < 1) {
            grid.style.gridTemplateColumns = `${leftFr}fr 8px ${1 - leftFr}fr`;
        }
    }

    resizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        const leftPanel = grid.querySelector('.panel-left');
        startLeftWidth = leftPanel.getBoundingClientRect().width;
        resizer.classList.add('dragging');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const gridRect = grid.getBoundingClientRect();
        const dx = e.clientX - startX;
        const newLeftWidth = startLeftWidth + dx;
        const totalWidth = gridRect.width - 8; // minus resizer width
        const minWidth = 250;
        const maxWidth = totalWidth - minWidth;

        if (newLeftWidth >= minWidth && newLeftWidth <= maxWidth) {
            const leftFr = newLeftWidth / totalWidth;
            const rightFr = 1 - leftFr;
            grid.style.gridTemplateColumns = `${leftFr}fr 8px ${rightFr}fr`;
        }
    });

    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            resizer.classList.remove('dragging');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            // Save ratio
            const gridRect = grid.getBoundingClientRect();
            const leftPanel = grid.querySelector('.panel-left');
            const leftFr = leftPanel.getBoundingClientRect().width / (gridRect.width - 8);
            localStorage.setItem(GRID_RATIO_KEY, leftFr.toString());
        }
    });
})();

// ============== Regex Tester ==============
(function() {
    const patternInput = document.getElementById('regex-pattern');
    const testStringInput = document.getElementById('regex-test-string');
    const resultDiv = document.getElementById('regex-result');
    const testBtn = document.getElementById('regex-test-btn');
    const findBtn = document.getElementById('regex-find-btn');
    const toggleBtn = document.getElementById('regex-tester-toggle');
    const content = document.getElementById('regex-tester-content');

    // Toggle collapse
    toggleBtn.addEventListener('click', () => {
        const isCollapsed = content.style.display === 'none';
        content.style.display = isCollapsed ? 'block' : 'none';
        toggleBtn.textContent = isCollapsed ? '▼' : '▶';
    });

    // Sample buttons
    document.getElementById('regex-samples').addEventListener('click', (e) => {
        if (e.target.classList.contains('regex-sample')) {
            const pattern = e.target.dataset.pattern;
            const testStr = e.target.dataset.test;
            patternInput.value = pattern;
            testStringInput.value = testStr;
            testBtn.click(); // Auto-run the test
        }
    });

    function showResult(type, html) {
        resultDiv.className = 'regex-result show ' + type;
        resultDiv.innerHTML = html;
    }

    // Test matches() - full string must match
    testBtn.addEventListener('click', () => {
        const pattern = patternInput.value.trim();
        const testStr = testStringInput.value;

        if (!pattern) {
            showResult('error', '⚠️ Please enter a regex pattern');
            return;
        }

        try {
            // Java regex: matches() requires full string match, so we anchor it
            const regex = new RegExp('^(?:' + pattern + ')$');
            const match = regex.exec(testStr);

            if (match) {
                let html = `<div>✓ <strong>matches()</strong> returns <span class="val-true">true</span></div>`;
                html += `<div style="margin-top:0.25rem">Full match: <span class="regex-match-highlight">${escapeHtml(match[0])}</span></div>`;

                // Show captured groups if any
                if (match.length > 1) {
                    html += '<div class="regex-groups"><strong>Captured groups:</strong>';
                    for (let i = 1; i < match.length; i++) {
                        html += `<div class="regex-group-item"><span class="regex-group-name">Group ${i}:</span> <span class="regex-group-value">${escapeHtml(match[i] || '(empty)')}</span></div>`;
                    }
                    html += '</div>';
                }
                showResult('match', html);
            } else {
                let html = `<div>✗ <strong>matches()</strong> returns <span class="val-false">false</span></div>`;
                html += `<div style="margin-top:0.25rem;color:#94a3b8">Pattern does not match the entire string</div>`;

                // Check if find() would match
                const findRegex = new RegExp(pattern);
                const findMatch = findRegex.exec(testStr);
                if (findMatch) {
                    html += `<div style="margin-top:0.35rem;color:#fcd34d">💡 Tip: <strong>find()</strong> would match: "${escapeHtml(findMatch[0])}"</div>`;
                }
                showResult('no-match', html);
            }
        } catch (e) {
            showResult('error', `⚠️ Invalid regex: ${escapeHtml(e.message)}`);
        }
    });

    // Test find() - partial match
    findBtn.addEventListener('click', () => {
        const pattern = patternInput.value.trim();
        const testStr = testStringInput.value;

        if (!pattern) {
            showResult('error', '⚠️ Please enter a regex pattern');
            return;
        }

        try {
            const regex = new RegExp(pattern, 'g');
            const matches = [];
            let match;
            while ((match = regex.exec(testStr)) !== null) {
                matches.push({ index: match.index, value: match[0], groups: match.slice(1) });
                if (match.index === regex.lastIndex) regex.lastIndex++; // Avoid infinite loop
            }

            if (matches.length > 0) {
                let html = `<div>✓ <strong>find()</strong> returns <span class="val-true">true</span> (${matches.length} match${matches.length > 1 ? 'es' : ''})</div>`;

                // Highlight matches in the string
                let highlighted = testStr;
                let offset = 0;
                matches.forEach(m => {
                    const before = highlighted.substring(0, m.index + offset);
                    const matched = highlighted.substring(m.index + offset, m.index + offset + m.value.length);
                    const after = highlighted.substring(m.index + offset + m.value.length);
                    const replacement = `<span class="regex-match-highlight">${escapeHtml(matched)}</span>`;
                    highlighted = before + replacement + after;
                    offset += replacement.length - m.value.length;
                });
                html += `<div style="margin-top:0.25rem;word-break:break-all">${highlighted}</div>`;

                // Show groups for first match
                if (matches[0].groups.length > 0) {
                    html += '<div class="regex-groups"><strong>Captured groups (first match):</strong>';
                    matches[0].groups.forEach((g, i) => {
                        html += `<div class="regex-group-item"><span class="regex-group-name">Group ${i + 1}:</span> <span class="regex-group-value">${escapeHtml(g || '(empty)')}</span></div>`;
                    });
                    html += '</div>';
                }
                showResult('match', html);
            } else {
                let html = `<div>✗ <strong>find()</strong> returns <span class="val-false">false</span></div>`;
                html += `<div style="margin-top:0.25rem;color:#94a3b8">No matches found in the string</div>`;
                showResult('no-match', html);
            }
        } catch (e) {
            showResult('error', `⚠️ Invalid regex: ${escapeHtml(e.message)}`);
        }
    });

    // Also test on Enter key
    patternInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') testBtn.click(); });
    testStringInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') testBtn.click(); });
})();
</script>
</body>
</html>
